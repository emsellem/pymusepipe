<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pymusepipe.align_pipe &mdash; pymusepipe 2.19.9 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> pymusepipe
          </a>
              <div class="version">
                2.19.9
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../welcome.html">Welcome</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../alignment.html">Alignment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mosaicking.html">Mosaicking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../convolution.html">Convolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../phangs_example.html">PHANGS pipeline example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/modules.html">Module Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pymusepipe</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pymusepipe.align_pipe</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pymusepipe.align_pipe</h1><div class="highlight"><pre>
<span></span><span class="c1">#Creating a plot showing the normalisation arising from a polypar object Licensed under a MIT license - see LICENSE</span>

<span class="sd">&quot;&quot;&quot;MUSE-PHANGS alignement module. This module can be used to align MUSE</span>
<span class="sd">reconstructed images either with each others or using a reference background</span>
<span class="sd">image. It spits the results out in a Fits table which can then be used</span>
<span class="sd">to process and mosaic Muse PIXTABLES via the MUSE ESO pipeline. </span>
<span class="sd">It includes a normalisation factor, an estimate of the background, </span>
<span class="sd">as well as any potential rotation. Fine tuning</span>
<span class="sd">can be done by hand by the user, using a set of reference plots.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__authors__</span> <span class="o">=</span> <span class="s2">&quot;Eric Emsellem&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;(c) 2017, ESO + CRAL&quot;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;MIT License&quot;</span>
<span class="n">__contact__</span> <span class="o">=</span> <span class="s2">&quot; &lt;eric.emsellem@eso.org&gt;&quot;</span>

<span class="c1"># Import general modules</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span> <span class="k">as</span> <span class="n">joinpath</span>

<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="c1"># Import Matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Import Numpy Scipy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">correlate</span>

<span class="c1"># Astropy</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">wcs</span> <span class="k">as</span> <span class="n">awcs</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">fits</span> <span class="k">as</span> <span class="n">pyfits</span>
<span class="kn">from</span> <span class="nn">astropy.io</span> <span class="kn">import</span> <span class="n">ascii</span>
<span class="kn">from</span> <span class="nn">astropy.modeling</span> <span class="kn">import</span> <span class="n">models</span><span class="p">,</span> <span class="n">fitting</span>
<span class="kn">from</span> <span class="nn">astropy.table</span> <span class="kn">import</span> <span class="n">Table</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>

<span class="c1"># Import mpdaf</span>
<span class="kn">from</span> <span class="nn">mpdaf.obj</span> <span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">WCS</span>

<span class="c1"># Import needed modules from pymusepipe</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">util_pipe</span> <span class="k">as</span> <span class="n">upipe</span>  <span class="c1"># noqua: E402</span>
<span class="kn">from</span> <span class="nn">.config_pipe</span> <span class="kn">import</span> <span class="n">mjd_names</span><span class="p">,</span> <span class="n">date_names</span><span class="p">,</span> <span class="n">tpl_names</span>
<span class="kn">from</span> <span class="nn">.config_pipe</span> <span class="kn">import</span> <span class="n">dataset_names</span><span class="p">,</span> <span class="n">iexpo_names</span><span class="p">,</span> <span class="n">dict_listObject</span>
<span class="kn">from</span> <span class="nn">.graph_pipe</span> <span class="kn">import</span> <span class="p">(</span><span class="n">plot_polypar</span><span class="p">,</span> <span class="n">plot_compare_contours</span><span class="p">,</span>
                         <span class="n">plot_compare_cuts</span><span class="p">,</span> <span class="n">plot_compare_diff</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.util_image</span> <span class="kn">import</span> <span class="n">my_linear_model</span><span class="p">,</span> <span class="n">flatclean_image</span><span class="p">,</span> <span class="n">get_normfactor</span><span class="p">,</span> <span class="n">mask_point_sources</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">reproject</span>
    <span class="kn">from</span> <span class="nn">reproject</span> <span class="kn">import</span> <span class="n">reproject_interp</span> <span class="k">as</span> <span class="n">repro_interp</span>
    <span class="kn">from</span> <span class="nn">reproject</span> <span class="kn">import</span> <span class="n">reproject_exact</span> <span class="k">as</span> <span class="n">repro_exact</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;If you wish to use reproject, please install &quot;</span>
                        <span class="s2">&quot;it via: pip install reproject.&quot;</span><span class="p">)</span>


<span class="c1"># Skimage if you have it</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">skimage</span>
    <span class="kn">from</span> <span class="nn">skimage.registration</span> <span class="kn">import</span> <span class="n">phase_cross_correlation</span>
    <span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">transform</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;If you wish to use skimage for image registration, &quot;</span>
                        <span class="s2">&quot;please install it via &quot;</span>
                        <span class="s2">&quot;    pip install scikit-image &quot;</span>
                        <span class="s2">&quot;or  conda install scikit-image&quot;</span><span class="p">)</span>


<span class="c1"># Spacepylot</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">spacepylot</span> <span class="k">as</span> <span class="nn">spp</span>
    <span class="kn">import</span> <span class="nn">spacepylot.alignment</span> <span class="k">as</span> <span class="nn">sppalign</span>
    <span class="kn">import</span> <span class="nn">spacepylot.plotting</span> <span class="k">as</span> <span class="nn">spppl</span>
    <span class="kn">from</span> <span class="nn">spacepylot.alignment_utilities</span> <span class="kn">import</span> <span class="n">TranslationTransform</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;If you wish to use spacepylot please install it via&quot;</span>
                        <span class="s2">&quot;pip install or conda install or cloning the github version&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="is_sequence"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.is_sequence">[docs]</a><span class="k">def</span> <span class="nf">is_sequence</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test if sequence and return the boolean result</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg : input argument</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result: boolean</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s2">&quot;strip&quot;</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">)</span> <span class="ow">or</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">))</span></div>


<span class="c1"># ================== Default units ======================== #</span>
<span class="c1"># Define useful units</span>
<span class="n">default_muse_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">erg</span> <span class="o">/</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">cm</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">cm</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">second</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">AA</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.e-20</span>
<span class="n">default_reference_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">microJansky</span>

<span class="n">dict_equivalencies</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;WFI_BB&quot;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">spectral_density</span><span class="p">(</span><span class="mf">6483.58</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">AA</span><span class="p">),</span>
                      <span class="s2">&quot;DUPONT_R&quot;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">spectral_density</span><span class="p">(</span><span class="mf">6483.58</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">AA</span><span class="p">),</span>
                      <span class="s2">&quot;Legacy_r&quot;</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">spectral_density</span><span class="p">(</span><span class="mf">6483.58</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">AA</span><span class="p">)}</span>
<span class="c1"># ================== Useful function ====================== #</span>


<div class="viewcode-block" id="get_conversion_factor"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.get_conversion_factor">[docs]</a><span class="k">def</span> <span class="nf">get_conversion_factor</span><span class="p">(</span><span class="n">input_unit</span><span class="p">,</span> <span class="n">output_unit</span><span class="p">,</span> <span class="n">filter_name</span><span class="o">=</span><span class="s2">&quot;WFI&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Conversion of units from an input one</span>
<span class="sd">    to an output one</span>
<span class="sd">     </span>
<span class="sd">    Input</span>
<span class="sd">    -----</span>
<span class="sd">    input_unit: astropy unit</span>
<span class="sd">        Input astropy unit to analyse</span>
<span class="sd">    output_unit: astropy unit</span>
<span class="sd">        Astropy unit to compare to input unit.</span>
<span class="sd">    equivalencies: astropy equivalency</span>
<span class="sd">        Used in case there is an existing equivalency</span>
<span class="sd">        to help the conversion</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    conversion: astropy unit conversion</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">filter_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dict_equivalencies</span><span class="p">:</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Didn&#39;t find conversion for this filter. &quot;</span>
                            <span class="s2">&quot;Using 1.0 as a conversion factor&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">1.0</span>

    <span class="n">equivalencies</span> <span class="o">=</span> <span class="n">dict_equivalencies</span><span class="p">[</span><span class="n">filter_name</span><span class="p">]</span>
    <span class="c1"># First testing if the quantities are Quantity</span>
    <span class="c1"># If not, transform them </span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_unit</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">quantity</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_unit</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Unit</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">CompositeUnit</span><span class="p">)):</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Input provided unit could not be converted&quot;</span><span class="p">)</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Using 1.0 as a conversion factor&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">input_unit</span> <span class="o">=</span> <span class="n">input_unit</span> <span class="o">*</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">quantity</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Unit</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">CompositeUnit</span><span class="p">)):</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Output provided unit could not be converted&quot;</span><span class="p">)</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Using 1.0 as a conversion factor&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_unit</span> <span class="o">=</span> <span class="n">output_unit</span> <span class="o">*</span> <span class="mf">1.0</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">input_unit</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">output_unit</span><span class="p">):</span>
        <span class="c1"># if not equivalent we try a spectral density equivalence</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">input_unit</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">output_unit</span><span class="p">,</span>
                                             <span class="n">equivalencies</span><span class="o">=</span><span class="n">equivalencies</span><span class="p">):</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Provided units for reference &quot;</span>
                                <span class="s2">&quot;and MUSE images are not equivalent&quot;</span><span class="p">)</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;A conversion factor of 1.0 will thus be used&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">input_unit</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to</span><span class="p">(</span>
                <span class="n">output_unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="n">equivalencies</span><span class="p">)</span> <span class="o">*</span> <span class="n">input_unit</span><span class="o">.</span><span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">input_unit</span><span class="o">.</span><span class="n">unit</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">output_unit</span><span class="p">)</span> <span class="o">*</span> <span class="n">input_unit</span><span class="o">.</span><span class="n">value</span></div>


<div class="viewcode-block" id="arcsec_to_pixel"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.arcsec_to_pixel">[docs]</a><span class="k">def</span> <span class="nf">arcsec_to_pixel</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">xy_arcsec</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Transform from arcsec to pixel for the muse image</span>
<span class="sd">    using the hdu to extract the WCS, hence the scaling.</span>
<span class="sd">     </span>
<span class="sd">    Input</span>
<span class="sd">    -----</span>
<span class="sd">    hdu: astropy hdu (fits)</span>
<span class="sd">        Input hdu which includes a WCS</span>
<span class="sd">    xy_arcsec: list of 2 floats ([0,0])</span>
<span class="sd">        Coordinates to transform from arcsec to pixel.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xpix, ypix: tuple or list of 2 floats</span>
<span class="sd">        Pixel coordinates</span>

<span class="sd">    See also: pixel_to_arcsec (align_pipe.py)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Matrix</span>
    <span class="n">input_wcs</span> <span class="o">=</span> <span class="n">awcs</span><span class="o">.</span><span class="n">WCS</span><span class="p">(</span><span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
    <span class="n">scale_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">input_wcs</span><span class="o">.</span><span class="n">pixel_scale_matrix</span> <span class="o">*</span> <span class="mf">3600.</span><span class="p">)</span>

    <span class="c1"># Transformation in Pixels</span>
    <span class="n">dels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xy_arcsec</span><span class="p">)</span>
    <span class="n">xpix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dels</span> <span class="o">*</span> <span class="n">scale_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>
    <span class="n">ypix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dels</span> <span class="o">*</span> <span class="n">scale_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
    <span class="k">return</span> <span class="n">xpix</span><span class="p">,</span> <span class="n">ypix</span></div>


<div class="viewcode-block" id="pixel_to_arcsec"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.pixel_to_arcsec">[docs]</a><span class="k">def</span> <span class="nf">pixel_to_arcsec</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">xy_pixel</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;Transform from arcsec to pixel for the muse image</span>
<span class="sd">    using the hdu to extract the WCS, hence the scaling.</span>
<span class="sd">     </span>
<span class="sd">    Input</span>
<span class="sd">    -----</span>
<span class="sd">    hdu: astropy hdu (fits)</span>
<span class="sd">        Input hdu which includes a WCS</span>
<span class="sd">    xy_pixel: tuple or list of 2 floats ((0,0))</span>
<span class="sd">        Coordinates to transform from pixel to arcsec</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xarc, yarc: 2 floats</span>
<span class="sd">        Arcseconds coordinates</span>

<span class="sd">    See also: arcsec_to_pixel (align_pipe.py)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Matrix</span>
    <span class="n">input_wcs</span> <span class="o">=</span> <span class="n">awcs</span><span class="o">.</span><span class="n">WCS</span><span class="p">(</span><span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

    <span class="c1"># Transformation in arcsecond</span>
    <span class="n">dels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xy_pixel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">xarc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dels</span> <span class="o">*</span> <span class="n">input_wcs</span><span class="o">.</span><span class="n">pixel_scale_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="mf">3600.</span><span class="p">)</span>
    <span class="n">yarc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dels</span> <span class="o">*</span> <span class="n">input_wcs</span><span class="o">.</span><span class="n">pixel_scale_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="mf">3600.</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">xarc</span><span class="p">,</span> <span class="n">yarc</span></div>


<div class="viewcode-block" id="rotate_pixtables"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.rotate_pixtables">[docs]</a><span class="k">def</span> <span class="nf">rotate_pixtables</span><span class="p">(</span><span class="n">folder</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">name_suffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">list_ifu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">angle</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Will update the derotator angle in each of the 24 pixtables</span>
<span class="sd">    Using a loop on rotate_pixtable</span>

<span class="sd">    Will thus update the HIERARCH ESO INS DROT POSANG keyword.</span>

<span class="sd">    Input</span>
<span class="sd">    -----</span>
<span class="sd">    folder: str</span>
<span class="sd">        name of the folder where the PIXTABLE are</span>
<span class="sd">    name_suffix: str</span>
<span class="sd">        name of the suffix to be used on top of PIXTABLE_OBJECT</span>
<span class="sd">    list_ifu: list[int]</span>
<span class="sd">        List of Pixtable numbers. If None, will do all 24</span>
<span class="sd">    angle: float</span>
<span class="sd">        Angle to rotate (in degrees)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">list_ifu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">list_ifu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">nifu</span> <span class="ow">in</span> <span class="n">list_ifu</span><span class="p">:</span>
        <span class="n">rotate_pixtable</span><span class="p">(</span><span class="n">folder</span><span class="o">=</span><span class="n">folder</span><span class="p">,</span> <span class="n">name_suffix</span><span class="o">=</span><span class="n">name_suffix</span><span class="p">,</span> <span class="n">nifu</span><span class="o">=</span><span class="n">nifu</span><span class="p">,</span>
                        <span class="n">angle</span><span class="o">=</span><span class="n">angle</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="rotate_pixtable"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.rotate_pixtable">[docs]</a><span class="k">def</span> <span class="nf">rotate_pixtable</span><span class="p">(</span><span class="n">folder</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">name_suffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">nifu</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rotate a single IFU PIXTABLE_OBJECT</span>
<span class="sd">    Will thus update the HIERARCH ESO INS DROT POSANG keyword.</span>

<span class="sd">    Input</span>
<span class="sd">    -----</span>
<span class="sd">    folder: str</span>
<span class="sd">        name of the folder where the PIXTABLE are</span>
<span class="sd">    name_suffix: str</span>
<span class="sd">        name of the suffix to be used on top of PIXTABLE_OBJECT</span>
<span class="sd">    nifu: int</span>
<span class="sd">        Pixtable number. Default is 1</span>
<span class="sd">    angle: float</span>
<span class="sd">        Angle to rotate (in degrees)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">angle_keyword</span> <span class="o">=</span> <span class="s2">&quot;HIERARCH ESO INS DROT POSANG&quot;</span>
    <span class="n">angle_orig_keyword</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> ORIG&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">angle_keyword</span><span class="p">)</span>

    <span class="n">pixtable_basename</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;pixtable_basename&quot;</span><span class="p">,</span>
                                   <span class="n">dict_listObject</span><span class="p">[</span><span class="s1">&#39;OBJECT&#39;</span><span class="p">])</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;prefix&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">name_pixtable</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}{1}</span><span class="s2">_</span><span class="si">{2}</span><span class="s2">-</span><span class="si">{3:02d}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">pixtable_basename</span><span class="p">,</span>
                                                     <span class="n">name_suffix</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">nifu</span><span class="p">))</span>
    <span class="n">fullname_pixtable</span> <span class="o">=</span> <span class="n">joinpath</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">name_pixtable</span><span class="p">)</span>
    <span class="n">fakemode</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fakemode&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Check if table is there</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fullname_pixtable</span><span class="p">):</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="s2">&quot;Input Pixtable </span><span class="si">{0}</span><span class="s2"> does not exist - Aborting&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">fullname_pixtable</span><span class="p">))</span>
        <span class="k">return</span>

    <span class="c1"># Continue with updating the table</span>
    <span class="n">mypix</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fullname_pixtable</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;update&#39;</span><span class="p">)</span>
    <span class="n">hd</span> <span class="o">=</span> <span class="n">mypix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fakemode</span> <span class="ow">and</span> <span class="n">angle</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">angle_orig_keyword</span> <span class="ow">in</span> <span class="n">hd</span><span class="p">:</span>
            <span class="n">hd</span><span class="p">[</span><span class="n">angle_orig_keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">hd</span><span class="p">[</span><span class="n">angle_keyword</span><span class="p">]</span>
        <span class="n">hd</span><span class="p">[</span><span class="n">angle_keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">hd</span><span class="p">[</span><span class="n">angle_orig_keyword</span><span class="p">]</span> <span class="o">+</span> <span class="n">angle</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Updating INS DROT POSANG for </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_pixtable</span><span class="p">))</span>
        <span class="n">mypix</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="c1"># Reading the result and printing</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== </span><span class="si">{}</span><span class="s2"> === &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_pixtable</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">angle_orig_keyword</span> <span class="ow">in</span> <span class="n">hd</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Present Angle [No Change] (deg): </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hd</span><span class="p">[</span><span class="n">angle_keyword</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Orig / New / Rotation Angle (deg): </span><span class="si">{0:8.4f}</span><span class="s2"> / </span><span class="si">{1:8.4f}</span><span class="s2"> / </span><span class="si">{2:8.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">hd</span><span class="p">[</span><span class="n">angle_orig_keyword</span><span class="p">],</span>
            <span class="n">hd</span><span class="p">[</span><span class="n">angle_keyword</span><span class="p">],</span>
            <span class="nb">float</span><span class="p">(</span><span class="n">hd</span><span class="p">[</span><span class="n">angle_keyword</span><span class="p">])</span> <span class="o">-</span> <span class="n">hd</span><span class="p">[</span><span class="n">angle_orig_keyword</span><span class="p">]))</span></div>


<div class="viewcode-block" id="align_hdu"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.align_hdu">[docs]</a><span class="k">def</span> <span class="nf">align_hdu</span><span class="p">(</span><span class="n">hdu_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hdu_to_align</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_rotation</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">to_align_rotation</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
              <span class="n">conversion_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">use_mpdaf</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Project the reference image onto the MUSE dataset</span>
<span class="sd">    Hidden function, as only used internally</span>

<span class="sd">    Input</span>
<span class="sd">    -----</span>
<span class="sd">    hdu_target: HDU [None]</span>
<span class="sd">        Target hdu (on to which to project)</span>
<span class="sd">    hdu_to_align: HDU [None]</span>
<span class="sd">         Hdu to be aligned</span>
<span class="sd">    target_rotation: float [0]</span>
<span class="sd">        Rotation angle in degrees of the target hdu</span>
<span class="sd">    to_align_rotation: float [0]</span>
<span class="sd">        Rotation angle in degrees of the to be aligned hdu</span>
<span class="sd">    conversion_factor: float</span>
<span class="sd">        Factor to be applied to the to_align hdu</span>
<span class="sd">    use_mpdaf: bool</span>
<span class="sd">        If True, use mpdaf to project. This is not recommended.</span>
<span class="sd">        If False, use reproject. This is the recommended option (default)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hdu_repr: HDU</span>
<span class="sd">        Reprojected HDU. None if nothing is provided</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">hdu_target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">hdu_to_align</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Getting the reference image data and WCS</span>
        <span class="n">wcs_to_align</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="n">hdr</span><span class="o">=</span><span class="n">hdu_to_align</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
        <span class="c1"># If there is a rotation of the WCS we remove it</span>
        <span class="k">if</span> <span class="n">to_align_rotation</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">wcs_to_align</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="n">to_align_rotation</span><span class="p">)</span>
        <span class="n">ima_to_align</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">hdu_to_align</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="n">conversion_factor</span><span class="p">,</span>
                             <span class="n">wcs</span><span class="o">=</span><span class="n">wcs_to_align</span><span class="p">)</span>

        <span class="c1"># Apply differential RA if using MPDAF to fix the reference</span>
        <span class="c1"># Problem existing when using align_with_image</span>
        <span class="k">if</span> <span class="n">use_mpdaf</span><span class="p">:</span>
            <span class="n">ra_target</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="n">hdu_target</span><span class="o">.</span><span class="n">header</span><span class="p">)</span><span class="o">.</span><span class="n">to_header</span><span class="p">()[</span><span class="s1">&#39;CRVAL1&#39;</span><span class="p">]</span>
            <span class="n">ra_to_align</span> <span class="o">=</span> <span class="n">ima_to_align</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">to_header</span><span class="p">()[</span><span class="s1">&#39;CRVAL1&#39;</span><span class="p">]</span>
            <span class="n">dec_to_align</span> <span class="o">=</span> <span class="n">ima_to_align</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">to_header</span><span class="p">()[</span><span class="s1">&#39;CRVAL2&#39;</span><span class="p">]</span>
            <span class="n">dra</span> <span class="o">=</span> <span class="n">ra_target</span> <span class="o">-</span> <span class="n">ra_to_align</span>
            <span class="n">diffang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">dra</span><span class="p">))</span>
                                           <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">dec_to_align</span><span class="p">)))</span> <span class="o">**</span> <span class="mi">2</span>
                                           <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">dec_to_align</span><span class="p">)))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Differential angle for this comparison is &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">diffang</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> (using mpdaf needs that fix)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diffang</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Getting the MUSE image data and WCS</span>
        <span class="n">wcs_target</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="n">hdr</span><span class="o">=</span><span class="n">hdu_target</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

        <span class="c1"># Fixing the differential angle when using mpdaf</span>
        <span class="c1"># For repro, the initial value is correct. For mpdaf it needs</span>
        <span class="c1"># the correction as the reference RA is different when projecting</span>
        <span class="c1"># - namely = keeping the original RA as a reference -</span>
        <span class="n">fixed_target_rotation</span> <span class="o">=</span> <span class="n">target_rotation</span> <span class="o">-</span> <span class="n">diffang</span>

        <span class="c1"># Doing the rotation now on the target WCS</span>
        <span class="k">if</span> <span class="n">fixed_target_rotation</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
            <span class="n">wcs_target</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="o">-</span><span class="n">fixed_target_rotation</span><span class="p">)</span>
        <span class="n">ima_target</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">hdu_target</span><span class="o">.</span><span class="n">data</span><span class="p">),</span>
                           <span class="n">wcs</span><span class="o">=</span><span class="n">wcs_target</span><span class="p">)</span>
        <span class="n">hdu_rot_target</span> <span class="o">=</span> <span class="n">ima_target</span><span class="o">.</span><span class="n">get_data_hdu</span><span class="p">()</span>

        <span class="c1"># Aligning the reference image with the MUSE image using mpdaf</span>
        <span class="c1"># align_with_image</span>

        <span class="k">if</span> <span class="n">use_mpdaf</span><span class="p">:</span>
            <span class="n">ima_aligned</span> <span class="o">=</span> <span class="n">ima_to_align</span><span class="o">.</span><span class="n">align_with_image</span><span class="p">(</span><span class="n">ima_target</span><span class="p">,</span> <span class="n">flux</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">hdu_aligned</span> <span class="o">=</span> <span class="n">ima_aligned</span><span class="o">.</span><span class="n">get_data_hdu</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Change of area</span>
            <span class="n">newinc</span> <span class="o">=</span> <span class="n">ima_target</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">get_axis_increments</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
            <span class="n">oldinc</span> <span class="o">=</span> <span class="n">ima_to_align</span><span class="o">.</span><span class="n">wcs</span><span class="o">.</span><span class="n">get_axis_increments</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
            <span class="n">change_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">newinc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">oldinc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> \
                          <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">newinc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">oldinc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">daligned</span> <span class="o">=</span> <span class="n">repro_interp</span><span class="p">(</span><span class="n">ima_to_align</span><span class="o">.</span><span class="n">get_data_hdu</span><span class="p">(),</span>
                                    <span class="n">ima_target</span><span class="o">.</span><span class="n">get_data_hdu</span><span class="p">()</span><span class="o">.</span><span class="n">header</span><span class="p">,</span>
                                    <span class="n">return_footprint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">hdu_aligned</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">daligned</span> <span class="o">*</span> <span class="n">change_area</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">hdu_aligned</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">diffang</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">hdu_rot_target</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">hdu_target</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: please provide target HDU to allow reprojection&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hdu_rot_target</span><span class="p">,</span> <span class="n">hdu_aligned</span><span class="p">,</span> <span class="n">diffang</span></div>


<div class="viewcode-block" id="init_plot_optical_flow"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.init_plot_optical_flow">[docs]</a><span class="k">def</span> <span class="nf">init_plot_optical_flow</span><span class="p">(</span><span class="n">opflow</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Initialise the optical flow plot using the AlignmentPlotting</span>

<span class="sd">    Input</span>
<span class="sd">    -----</span>
<span class="sd">    opflow: optical flow instance (see spacepylot)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    An optical flow plot instance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialise the plot</span>
    <span class="k">return</span> <span class="n">spppl</span><span class="o">.</span><span class="n">AlignmentPlotting</span><span class="o">.</span><span class="n">from_align_object</span><span class="p">(</span><span class="n">opflow</span><span class="p">)</span></div>


<span class="c1">#################################################################</span>
<span class="c1"># ================== END Useful functions ===================== #</span>
<span class="c1">#################################################################</span>
<span class="c1"># Main alignment Class</span>
<div class="viewcode-block" id="AlignMuseDataset"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset">[docs]</a><span class="k">class</span> <span class="nc">AlignMuseDataset</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to align MUSE images onto a reference image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_reference</span><span class="p">,</span>
                 <span class="n">folder_reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">folder_muse_images</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">name_muse_images</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">sel_indices_images</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">median_window</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">subim_window</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">dynamic_range</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">border</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">hdu_ext</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                 <span class="n">chunk_size</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
                 <span class="n">firstguess</span><span class="o">=</span><span class="s2">&quot;crosscorr&quot;</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise the AlignMuseImages class.</span>
<span class="sd">        </span>
<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        name_reference: str</span>
<span class="sd">            Name of the reference image (fits file)</span>
<span class="sd">        folder_reference: str [&quot;&quot;]</span>
<span class="sd">            Folder name of the reference image</span>
<span class="sd">        folder_muse_images: str [&quot;&quot;]</span>
<span class="sd">            Folder name for the input images to compare</span>
<span class="sd">        name_muse_images: str or list</span>
<span class="sd">            List of names for the MUSE images (or str if only 1 image)</span>
<span class="sd">        suffix_muse_images: str</span>
<span class="sd">            Suffix to be used for muse image names if only a subset should be selected.</span>
<span class="sd">        filter_name: str</span>
<span class="sd">            Name of filter to consider when filtering the muse image names</span>
<span class="sd">        filter_suffix: str</span>
<span class="sd">            String defined to filter the image names. If not provided, will be defaulted</span>
<span class="sd">            to the provided filter_name.</span>
<span class="sd">        firstguess: str</span>
<span class="sd">            If &quot;crosscorr&quot;, will use cross-correlation to guess the alignment offsets.</span>
<span class="sd">            If &quot;fits&quot;, will use input fits OFFSET table to start with</span>
<span class="sd">            If set to None explicitly, will put 0&#39;s as start offsets.</span>
<span class="sd">            Default is &quot;crosscorr&quot;.</span>
<span class="sd">        name_offset_table: str</span>
<span class="sd">            Name of the fits OFFSET table. Only used as input as guess if &quot;firstguess&quot;</span>
<span class="sd">            is set to &quot;fits&quot;. This name will be the default name when saving</span>
<span class="sd">            the offsets in an OFFSET fits table.</span>
<span class="sd">        sel_indices_images: list [None]</span>
<span class="sd">            List of images to select from the given set</span>
<span class="sd">        median_window: int [10]</span>
<span class="sd">            Size of window used in median filter to extract features in</span>
<span class="sd">            cross-correlation.  Should be an odd integer</span>
<span class="sd">        subim_window: int [10]</span>
<span class="sd">            Size of window for fitting peak of cross-correlation function</span>
<span class="sd">        dynamic_range: float [10]</span>
<span class="sd">            Apply an arctan transform to data to suppress values more than</span>
<span class="sd">            DynamicRange times the median of the image</span>
<span class="sd">        border: int [10]</span>
<span class="sd">            Ignore pixels this close to the border in the cross correlation</span>
<span class="sd">        hdu_ext: tuple or list of 2 floats (0,1)</span>
<span class="sd">            Number of the extension for the input reference image </span>
<span class="sd">            and images to align, respectively. This is used to know</span>
<span class="sd">            where the data lies in the fits file.</span>
<span class="sd">        chunk_size: int [15]</span>
<span class="sd">            Size in pixels of the chunk used to bin and compute the </span>
<span class="sd">            normalisation factors</span>

<span class="sd">        Other keywords</span>
<span class="sd">        --------------</span>
<span class="sd">        verbose: bool [True]</span>
<span class="sd">            If True, spits out more verbose output</span>
<span class="sd">        plot: bool [True]</span>
<span class="sd">            If True, will provide plots</span>
<span class="sd">        debug: bool [False]</span>
<span class="sd">            If True, will provide some info to debug</span>
<span class="sd">            which will be stored in the python class</span>
<span class="sd">            as new attributes. Look for self._temp...</span>
<span class="sd">        use_polynorm: bool [True]</span>
<span class="sd">            Save the polynomial fitted slope and use as normalisation</span>
<span class="sd">            factors</span>
<span class="sd">        convert_units: bool [True]</span>
<span class="sd">            Use the given units to convert fluxes</span>
<span class="sd">        ref_unit: astropy unit</span>
<span class="sd">            Reference image unit</span>
<span class="sd">        muse_unit: astropy unit</span>
<span class="sd">            Input MUSE flux unit</span>
<span class="sd">        threshold: float [0]</span>
<span class="sd">            Default minimum flux to consider when processing the set of images</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Some input variables for the cross-correlation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;verbose&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;plot&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Using mpdaf or image_registration - Default is False</span>
        <span class="c1"># as mpdaf does not define the output WCS homogeneously</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_mpdaf</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_mpdaf&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_mpdaf</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Will use mpdaf for image regridding.&quot;</span><span class="p">)</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;WARNING: when using mpdaf, a potential extra rotation </span><span class="se">\n</span><span class="s2">&quot;</span>
                             <span class="s2">&quot;has to be applied to redefine the reference grid.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Will use image_registration for image regridding.&quot;</span><span class="p">)</span>

        <span class="c1"># Set of input parameters for the image processing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">border</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">border</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subim_window</span> <span class="o">=</span> <span class="n">subim_window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">median_window</span> <span class="o">=</span> <span class="n">median_window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_range</span> <span class="o">=</span> <span class="n">dynamic_range</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name_reference</span> <span class="o">=</span> <span class="n">name_reference</span>
        <span class="n">default_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">folder_reference</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">folder_reference</span> <span class="o">=</span> <span class="n">default_folder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">folder_reference</span> <span class="o">=</span> <span class="n">folder_reference</span>

        <span class="c1"># Debug option</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;In DEBUG Mode [more printing]&quot;</span><span class="p">)</span>
        <span class="c1"># Backward compatibility - TO BE REMOVED when fixed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backward_comp</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;backward_comp&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Check if folder reference exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_reference</span><span class="p">):</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="s2">&quot;Provided folder_reference is &quot;</span>
                              <span class="s2">&quot;not an existing folder&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name_muse_images</span> <span class="o">=</span> <span class="n">name_muse_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sel_indices_images</span> <span class="o">=</span> <span class="n">sel_indices_images</span>
        <span class="k">if</span> <span class="n">folder_muse_images</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">folder_muse_images</span> <span class="o">=</span> <span class="n">default_folder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">folder_muse_images</span> <span class="o">=</span> <span class="n">folder_muse_images</span>
        <span class="c1"># Check if folder muse images exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_muse_images</span><span class="p">):</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="s2">&quot;Provided folder_muse_images is &quot;</span>
                              <span class="s2">&quot;not an existing folder&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Creating the Header-Align folder</span>
        <span class="n">header_folder_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;header_folder_name&quot;</span><span class="p">,</span> <span class="s2">&quot;AlignHeaders&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header_folder_name</span> <span class="o">=</span> <span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_muse_images</span><span class="p">,</span> <span class="n">header_folder_name</span><span class="p">)</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">safely_create_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header_folder_name</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># Creating the Figure folder if needed</span>
        <span class="n">figures_folder_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;figures_folder_name&quot;</span><span class="p">,</span> <span class="s2">&quot;AlignFigures&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">figures_folder_name</span> <span class="o">=</span> <span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_muse_images</span><span class="p">,</span> <span class="n">figures_folder_name</span><span class="p">)</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">safely_create_folder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figures_folder_name</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># Getting the names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_hdr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;save_hdr&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_musehdr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;name_musehdr&quot;</span><span class="p">,</span> <span class="s2">&quot;muse&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_offmusehdr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;name_offmusehdr&quot;</span><span class="p">,</span> <span class="s2">&quot;offsetmuse&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suffix_images</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;suffix_muse_images&quot;</span><span class="p">,</span> <span class="s2">&quot;IMAGE_FOV&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;filter_name&quot;</span><span class="p">,</span> <span class="s2">&quot;Cousins_R&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_suffix</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;filter_suffix&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_name</span><span class="p">)</span>

        <span class="c1"># Use polynorm or not</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_polynorm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_polynorm&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Use rotation angles from the offset table if they exist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_rotangles</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;use_rotangles&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotangles</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;By default, rotation angles given in initial &quot;</span>
                                <span class="s2">&quot;offset table will be used if they exist. If &quot;</span>
                                <span class="s2">&quot;not, all initial rotation angles will be set to 0.&quot;</span><span class="p">)</span>

        <span class="c1"># Getting the unit conversions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_units</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;convert_units&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_units</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref_unit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ref_unit&quot;</span><span class="p">,</span> <span class="n">default_reference_unit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">muse_unit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;muse_unit&quot;</span><span class="p">,</span> <span class="n">default_muse_unit</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conversion_factor</span> <span class="o">=</span> <span class="n">get_conversion_factor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_unit</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">muse_unit</span><span class="p">,</span>
                                                           <span class="bp">self</span><span class="o">.</span><span class="n">filter_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conversion_factor</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Initialise the parameters for the first guess</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_corr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;phase_corr&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_subsamp</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;phase_subsamp&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">folder_offset_table</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;folder_offset_table&quot;</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">folder_muse_images</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">folder_output_table</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;folder_output_table&quot;</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">folder_offset_table</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_offset_table</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;name_offset_table&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Get the MUSE images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_list_muse_images</span><span class="p">()</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> MUSE images detected as input&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="s2">&quot;No MUSE images detected. Aborted&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;threshold&quot;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>

        <span class="c1"># Reset! all parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_init_guess_values</span><span class="p">()</span>

        <span class="c1"># Initialise the arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_alignment_arrays</span><span class="p">()</span>

        <span class="c1"># Which extension to be used for the ref and muse images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu_ext</span> <span class="o">=</span> <span class="n">hdu_ext</span>

        <span class="c1"># Open the Ref and MUSE image</span>
        <span class="n">status_open</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_hdu</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">status_open</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="s2">&quot;Problem in opening frames, please check your input&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Initialise the offsets using the cross-correlation or FITS table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_guess_offset</span><span class="p">(</span><span class="n">firstguess</span><span class="o">=</span><span class="n">firstguess</span><span class="p">)</span>

        <span class="c1"># Now doing the shifts and projections with the guess/input values</span>
        <span class="k">for</span> <span class="n">nima</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_alignment_ima</span><span class="p">(</span><span class="n">nima</span><span class="p">)</span>

<div class="viewcode-block" id="AlignMuseDataset.show_norm_factors"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.show_norm_factors">[docs]</a>    <span class="k">def</span> <span class="nf">show_norm_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print some information about the normalisation factors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Normalisation factors&quot;</span><span class="p">)</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Image # : InitFluxScale     SlopeFit       &quot;</span>
                         <span class="s2">&quot;NormFactor       Background&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nima</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">):</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Image </span><span class="si">{0:03d}</span><span class="s2">:  </span><span class="si">{1:10.6e}</span><span class="s2">   </span><span class="si">{2:10.6e}</span><span class="s2">     &quot;</span>
                             <span class="s2">&quot;</span><span class="si">{3:10.6e}</span><span class="s2">     </span><span class="si">{4:10.6e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">nima</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init_flux_scale</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_polypar</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_norm_factors</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_background</span><span class="p">[</span><span class="n">nima</span><span class="p">]))</span></div>

<div class="viewcode-block" id="AlignMuseDataset.show_linearfit_values"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.show_linearfit_values">[docs]</a>    <span class="k">def</span> <span class="nf">show_linearfit_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print some information about the linearly fitted parameters</span>
<span class="sd">        pertaining to the normalisation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Normalisation factors&quot;</span><span class="p">)</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Image # : BackGround        Slope&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nima</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">):</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Image </span><span class="si">{0:03d}</span><span class="s2">:  </span><span class="si">{1:10.6e}</span><span class="s2">   </span><span class="si">{2:10.6e}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">nima</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_polypar</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_polypar</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span></div>

    <span class="k">def</span> <span class="nf">_init_alignment_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise all list and image arrays which are needed</span>
<span class="sd">        for processing the alignment</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">list_offmuse_hdu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_wcs_offmuse_hdu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_proj_refhdu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_wcs_proj_refhdu</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>

        <span class="c1"># Initialise the needed arrays for the PCC offsets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcc_off_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcc_off_arcsec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcc_off_pixel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcc_off_init</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>

        <span class="c1"># Initialise the list of optical flows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optical_flows</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op_plots</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>

        <span class="c1"># Initialise the needed arrays for the cross-correlation offsets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cross_off_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_off_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cross_off_pixel</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cross_off_arcsec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cross_off_pixel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_off_arcsec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cross_off_pixel</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extra_rotangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_diffra_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extra_rotangles</span><span class="p">)</span>

        <span class="c1"># Cross normalisation for the images</span>
        <span class="c1"># This contains the parameters of the linear fit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ima_polypar</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>

        <span class="c1"># Normalisation factor to be saved or used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ima_norm_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ima_background</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ima_norm_factors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ima_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ima_norm_factors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_threshold</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_convolve_muse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ima_norm_factors</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_convolve_reference</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ima_norm_factors</span><span class="p">)</span>

        <span class="c1"># Default lists for date, mjd, tpls of the MUSE images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ima_dateobs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ima_mjdobs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ima_tplstart</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ima_iexpo</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ima_dataset</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>

<div class="viewcode-block" id="AlignMuseDataset.init_guess_offset"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.init_guess_offset">[docs]</a>    <span class="k">def</span> <span class="nf">init_guess_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise first guess, either from cross-correlation (default)</span>
<span class="sd">        or from an Offset FITS Table</span>
<span class="sd">         </span>
<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        firstguess: str</span>
<span class="sd">            If &quot;crosscorr&quot; uses cross-correlation to get the first guess</span>
<span class="sd">            of the offsets. If &quot;fits&quot; uses the input fits table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firstguess</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;firstguess&quot;</span><span class="p">,</span> <span class="s2">&quot;crosscorr&quot;</span><span class="p">)</span>

        <span class="c1"># Implement the guess</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstguess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;No initial guess shift: all set to 0&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_off_arcsec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_off_arcsec</span> <span class="o">*</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_off_pixel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_off_pixel</span> <span class="o">*</span> <span class="mf">0.0</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Forcing crosscorr if not recognised</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstguess</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pcc&quot;</span><span class="p">,</span> <span class="s2">&quot;crosscorr&quot;</span><span class="p">,</span> <span class="s2">&quot;fits&quot;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">firstguess</span> <span class="o">=</span> <span class="s2">&quot;crosscorr&quot;</span>
                <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Keyword &#39;firstguess&#39; not recognised&quot;</span><span class="p">)</span>
                <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Using Cross-Correlation as a first guess for the alignment&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstguess</span> <span class="o">==</span> <span class="s2">&quot;crosscorr&quot;</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Using cross-correlation as the initial guess&quot;</span><span class="p">)</span>
            <span class="c1"># find the cross correlation peaks for each image</span>
            <span class="c1"># This is using zero offset and zero rotation</span>
            <span class="c1"># as all parameters have been reset above</span>
            <span class="c1"># New values will be taken out from the cross-correlation or fits table</span>
            <span class="c1"># just below with the init_guess_offset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">find_cross_peak_listima</span><span class="p">()</span>
            <span class="c1"># Transfer the cross-correlation offsets to the initialisation offsets</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_off_arcsec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_off_arcsec</span> <span class="o">*</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_off_pixel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_off_pixel</span> <span class="o">*</span> <span class="mf">1.0</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstguess</span> <span class="o">==</span> <span class="s2">&quot;pcc&quot;</span><span class="p">:</span>
            <span class="c1"># We use PCC from spacepylot to get the first guess here</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_shift_from_pcc_listima</span><span class="p">()</span>
            <span class="c1"># Transfer the PCC offsets to the initialisation offsets</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_off_arcsec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcc_off_arcsec</span> <span class="o">*</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_off_pixel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcc_off_pixel</span> <span class="o">*</span> <span class="mf">1.0</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstguess</span> <span class="o">==</span> <span class="s2">&quot;fits&quot;</span><span class="p">:</span>
            <span class="c1"># Look for the offset table</span>
            <span class="n">exist_table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_offset_table</span><span class="p">(</span>
                <span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_offset_table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_offset_table</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">exist_table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Fits initialisation table not found, &quot;</span>
                                    <span class="s2">&quot;setting init value to 0&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reset_init_guess_values</span><span class="p">()</span>
                <span class="k">return</span>

            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Using input FITS table as initial guess: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name_offset_table</span><span class="p">))</span>
            <span class="c1"># First get the right indices for the table by comparing MJD_OBS</span>
            <span class="k">if</span> <span class="n">mjd_names</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_table</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Input table does not contain MJD_OBS column&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_reset_init_guess_values</span><span class="p">()</span>
                <span class="k">return</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">table_mjdobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_table</span><span class="p">[</span><span class="n">mjd_names</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]]</span>
            <span class="c1"># Now finding the right match with the Images</span>
            <span class="c1"># Warning, needs &gt; numpy 1.15.0</span>
            <span class="n">mjd_values</span><span class="p">,</span> <span class="n">ind_ima</span><span class="p">,</span> <span class="n">ind_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_mjdobs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_mjdobs</span><span class="p">,</span>
                <span class="n">return_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Extracting the flux scale from table</span>
            <span class="n">nonan_flux_scale_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset_table</span><span class="p">[</span><span class="s1">&#39;FLUX_SCALE&#39;</span><span class="p">]),</span>
                <span class="mf">1.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_table</span><span class="p">[</span><span class="s1">&#39;FLUX_SCALE&#39;</span><span class="p">])</span>
            <span class="c1"># Extracting the rotangle, but only if there</span>
            <span class="n">rotangle_exist</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ROTANGLE&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_table</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rotangle_exist</span><span class="p">:</span>
                <span class="n">nonan_rotangle_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset_table</span><span class="p">[</span><span class="s1">&#39;ROTANGLE&#39;</span><span class="p">]),</span>
                    <span class="mf">0.</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_table</span><span class="p">[</span><span class="s1">&#39;ROTANGLE&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Rotation angles not present in offset table. &quot;</span>
                                    <span class="s2">&quot;Please use argument &#39;extra_rotation&#39; &quot;</span>
                                    <span class="s2">&quot;in &#39;run&#39; to force a non zero value.&quot;</span><span class="p">)</span>

            <span class="c1"># Loop over the images, using MJD</span>
            <span class="k">for</span> <span class="n">nima</span><span class="p">,</span> <span class="n">mjd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ima_mjdobs</span><span class="p">):</span>
                <span class="c1"># Test if mjd is in the set of mjd_values</span>
                <span class="k">if</span> <span class="n">mjd</span> <span class="ow">in</span> <span class="n">mjd_values</span><span class="p">:</span>
                    <span class="c1"># Find the index of the value array where mjd</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mjd_values</span> <span class="o">==</span> <span class="n">mjd</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">init_off_arcsec</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">offset_table</span><span class="p">[</span><span class="s1">&#39;RA_OFFSET&#39;</span><span class="p">][</span><span class="n">ind_table</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span> <span class="o">*</span> <span class="mf">3600.</span> \
                        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_dec_muse</span><span class="p">[</span><span class="n">nima</span><span class="p">])),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">offset_table</span><span class="p">[</span><span class="s1">&#39;DEC_OFFSET&#39;</span><span class="p">][</span><span class="n">ind_table</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span> <span class="o">*</span> <span class="mf">3600.</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">init_flux_scale</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">nonan_flux_scale_table</span><span class="p">[</span><span class="n">ind_table</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">rotangle_exist</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">init_rotangles</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">nonan_rotangle_table</span><span class="p">[</span><span class="n">ind_table</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">init_rotangles</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="c1"># Otherwise use default values</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">init_flux_scale</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">init_off_arcsec</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">init_rotangles</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

                <span class="c1"># Transform into pixel values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init_off_pixel</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">arcsec_to_pixel</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">list_muse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">init_off_arcsec</span><span class="p">[</span><span class="n">nima</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_reset_init_guess_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the initial guess to 0. Hidden function as this is only</span>
<span class="sd">        used internally</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table_mjdobs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_off_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_off_arcsec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_flux_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_rotangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<div class="viewcode-block" id="AlignMuseDataset.open_offset_table"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.open_offset_table">[docs]</a>    <span class="k">def</span> <span class="nf">open_offset_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Read offset table from fits file</span>
<span class="sd">         </span>
<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        name_table: str</span>
<span class="sd">            Name of the input OFFSET table</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        status: None if no table name is given, False if file does not</span>
<span class="sd">            exist, True if it does</span>
<span class="sd">        Table: the result of a astropy.Table.read of the fits table</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;name_table&quot;</span><span class="p">):</span>
                <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="s2">&quot;No FITS table name provided, Aborting Open&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Table</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">name_table</span><span class="p">):</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;FITS Table (</span><span class="si">{0}</span><span class="s2">) does not &quot;</span>
                                <span class="s2">&quot; exist yet&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_table</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">Table</span><span class="p">()</span>

        <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">Table</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">name_table</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlignMuseDataset.show_offset_fromfits"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.show_offset_fromfits">[docs]</a>    <span class="k">def</span> <span class="nf">show_offset_fromfits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print offset table from fits file</span>
<span class="sd">         </span>
<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        name_table: str</span>
<span class="sd">            Name of the input OFFSET table</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exist_table</span><span class="p">,</span> <span class="n">fits_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_offset_table</span><span class="p">(</span><span class="n">name_table</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exist_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="p">((</span><span class="s1">&#39;RA_OFFSET&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fits_table</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;DEC_OFFSET&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fits_table</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="s2">&quot;Table does not contain &#39;RA/DEC_OFFSET&#39; &quot;</span>
                              <span class="s2">&quot;columns, Aborting&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Offset recorded in OFFSET_LIST Table&quot;</span><span class="p">)</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Total in ARCSEC&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nima</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">):</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Image </span><span class="si">{0:03d}</span><span class="s2"> - </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nima</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span><span class="p">[</span><span class="n">nima</span><span class="p">]))</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;          - </span><span class="si">{0:8.4f}</span><span class="s2"> </span><span class="si">{1:8.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;RA_OFFSET&#39;</span><span class="p">][</span><span class="n">nima</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3600</span>
                <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_dec_muse</span><span class="p">[</span><span class="n">nima</span><span class="p">])),</span>
                <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;DEC_OFFSET&#39;</span><span class="p">][</span><span class="n">nima</span><span class="p">]</span> <span class="o">*</span> <span class="mf">3600.</span><span class="p">))</span></div>

<div class="viewcode-block" id="AlignMuseDataset.print_images_names"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.print_images_names">[docs]</a>    <span class="k">def</span> <span class="nf">print_images_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print out the names of the images being considered for alignment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Image names&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nima</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">):</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0:03d}</span><span class="s2"> - </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nima</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span><span class="p">[</span><span class="n">nima</span><span class="p">]))</span></div>

<div class="viewcode-block" id="AlignMuseDataset.print_offsets_and_norms"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.print_offsets_and_norms">[docs]</a>    <span class="k">def</span> <span class="nf">print_offsets_and_norms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;_temp.txt&quot;</span><span class="p">,</span>
                                <span class="n">folder_output_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save all offsets and norms into filename. By default, file will</span>
<span class="sd">        be overwritten.</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        filename: str</span>
<span class="sd">            Name of file where the output will be written</span>
<span class="sd">        folder_output_file: str</span>
<span class="sd">            Name of output folder where the file will be written</span>
<span class="sd">        overwrite: bool</span>
<span class="sd">            Default is True</span>

<span class="sd">        Creates</span>
<span class="sd">        -------</span>
<span class="sd">            Ascii file named via the filename input argument</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">folder_output_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">folder_output_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">folder_output_table</span>
        <span class="n">fullname_file</span> <span class="o">=</span> <span class="n">joinpath</span><span class="p">(</span><span class="n">folder_output_file</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fullname_file</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
                <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;File exists and overwrite is False. &quot;</span>
                                    <span class="s2">&quot;Aborting.&quot;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;File exists but will be overwritten as&quot;</span>
                                    <span class="s2">&quot;overwrite is True.&quot;</span><span class="p">)</span>

        <span class="n">toff_arc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_off_arcsec</span>
        <span class="n">toff_pix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_off_pixel</span>
        <span class="n">trot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_rotangles</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nb&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">name</span><span class="p">[</span><span class="o">-</span><span class="mi">29</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span><span class="p">],</span>
                <span class="s1">&#39;xarc&#39;</span><span class="p">:</span> <span class="n">toff_arc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;yarc&#39;</span><span class="p">:</span> <span class="n">toff_arc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="s1">&#39;xpix&#39;</span><span class="p">:</span> <span class="n">toff_pix</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="s1">&#39;ypix&#39;</span><span class="p">:</span> <span class="n">toff_pix</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="s1">&#39;rot&#39;</span><span class="p">:</span> <span class="n">trot</span><span class="p">,</span>
                <span class="s1">&#39;norm&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ima_norm_factors</span><span class="p">,</span>
                <span class="s1">&#39;backg&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ima_background</span>
                <span class="p">}</span>

        <span class="n">ascii</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fullname_file</span><span class="p">,</span>
                    <span class="n">formats</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;nb&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%03d</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&gt;26&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;xarc&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%8.4f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;yarc&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%8.4f</span><span class="s1">&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;xpix&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%8.4f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;ypix&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%8.4f</span><span class="s1">&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;rot&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%8.4f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%10.6e</span><span class="s1">&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;backg&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">%10.6e</span><span class="s1">&#39;</span>
                             <span class="p">},</span>
                    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;fixed_width&#39;</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlignMuseDataset.show_offsets"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.show_offsets">[docs]</a>    <span class="k">def</span> <span class="nf">show_offsets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print out the offset from the Alignment class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;#---- Offset recorded so far ----#&quot;</span><span class="p">)</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;#    Name               OFFSETS  |ARCSEC|   &quot;</span>
                         <span class="s2">&quot;X        Y     |PIXEL|    X        Y      |ROT| (DEG)&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">nima</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">):</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0:03d}</span><span class="s2"> -</span><span class="si">{1:&gt;26}</span><span class="s2">  |ARCSEC|</span><span class="si">{2:8.4f}</span><span class="s2"> </span><span class="si">{3:8.4f}</span><span class="s2"> &quot;</span>
                             <span class="s2">&quot; |PIXEL|</span><span class="si">{4:8.4f}</span><span class="s2"> </span><span class="si">{5:8.4f}</span><span class="s2">  |ROT|</span><span class="si">{6:8.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                             <span class="n">nima</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span><span class="p">[</span><span class="n">nima</span><span class="p">][</span><span class="o">-</span><span class="mi">29</span><span class="p">:</span><span class="o">-</span><span class="mi">5</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_total_off_arcsec</span><span class="p">[</span><span class="n">nima</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_total_off_arcsec</span><span class="p">[</span><span class="n">nima</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_total_off_pixel</span><span class="p">[</span><span class="n">nima</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_total_off_pixel</span><span class="p">[</span><span class="n">nima</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_total_rotangles</span><span class="p">[</span><span class="n">nima</span><span class="p">]))</span></div>

<div class="viewcode-block" id="AlignMuseDataset.save_fits_offset_table"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.save_fits_offset_table">[docs]</a>    <span class="k">def</span> <span class="nf">save_fits_offset_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_output_table</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">folder_output_table</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">save_flux_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">save_other_params</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save the Offsets into a fits Table</span>
<span class="sd">         </span>
<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        folder_output_table: str [None]</span>
<span class="sd">            Folder of the output table. If None (default) the folder</span>
<span class="sd">            for the input offset table will be used or alternatively</span>
<span class="sd">            the folder of the MUSE images.</span>
<span class="sd">        name_output_table: str [None]</span>
<span class="sd">            Name of the output fits table. If None (default) it will</span>
<span class="sd">            use the one given in self.name_output_table</span>
<span class="sd">        overwrite: bool [False]</span>
<span class="sd">            If True, overwrite if the file exists</span>
<span class="sd">        suffix: str [&quot;&quot;]</span>
<span class="sd">            Suffix to be used to add to the input name. This is handy</span>
<span class="sd">            to just modify the given fits name with a suffix </span>
<span class="sd">            (e.g., version number).</span>
<span class="sd">        save_flux_scale: bool [True]</span>
<span class="sd">            If True, saving the flux in FLUX_SCALE</span>
<span class="sd">            If False, do not save the flux conversion</span>
<span class="sd">        save_other_params: bool [True]</span>
<span class="sd">            If True, saving the background + rotation</span>
<span class="sd">            If False, do not save these 2 parameters.</span>
<span class="sd">        </span>
<span class="sd">        Creates</span>
<span class="sd">        -------</span>
<span class="sd">        A fits table with the given name (using the suffix if any)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name_output_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_offset_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name_output_table</span> <span class="o">=</span> <span class="s2">&quot;DUMMY_OFFSET_TABLE.fits&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name_output_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_offset_table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">suffix</span> <span class="o">=</span> <span class="n">suffix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_output_table</span> <span class="o">=</span> <span class="n">name_output_table</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.fits&quot;</span><span class="p">,</span>
                                                           <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">suffix</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">folder_output_table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">folder_output_table</span> <span class="o">=</span> <span class="n">folder_output_table</span>
        <span class="n">exist_table</span><span class="p">,</span> <span class="n">fits_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_offset_table</span><span class="p">(</span>
            <span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_output_table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_output_table</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">exist_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="s2">&quot;Save is aborted&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Checking if overwrite and exist_table do go together</span>
        <span class="k">if</span> <span class="n">exist_table</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Table already exists, &quot;</span>
                                <span class="s2">&quot;but overwrite is set to False&quot;</span><span class="p">)</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;If you wish to overwrite the table </span><span class="si">{0}</span><span class="s2">, &quot;</span>
                                <span class="s2">&quot;please set overwrite to True&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                 <span class="n">name_output_table</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="c1"># Check if RA_OFFSET is there</span>
        <span class="n">exist_ra_offset</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;RA_OFFSET&#39;</span> <span class="ow">in</span> <span class="n">fits_table</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="c1"># First save the DATA and MJD references</span>
        <span class="n">fits_table</span><span class="p">[</span><span class="n">date_names</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ima_dateobs</span>
        <span class="n">fits_table</span><span class="p">[</span><span class="n">mjd_names</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ima_mjdobs</span>
        <span class="n">fits_table</span><span class="p">[</span><span class="n">tpl_names</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ima_tplstart</span>
        <span class="n">fits_table</span><span class="p">[</span><span class="n">iexpo_names</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ima_iexpo</span>
        <span class="n">fits_table</span><span class="p">[</span><span class="n">dataset_names</span><span class="p">[</span><span class="s1">&#39;table&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ima_dataset</span>

        <span class="c1"># Saving the final values</span>
        <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;RA_OFFSET&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_off_arcsec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">3600.</span> \
                                  <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_dec_muse</span><span class="p">))</span>
        <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;DEC_OFFSET&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_off_arcsec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">3600.</span>
        <span class="k">if</span> <span class="n">save_flux_scale</span><span class="p">:</span>
            <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;FLUX_SCALE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ima_norm_factors</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;FLUX_SCALE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">save_other_params</span><span class="p">:</span>
            <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;BACKGROUND&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ima_background</span>
            <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;ROTANGLE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_rotangles</span>

        <span class="c1"># Deal with RA_OFFSET_ORIG if needed</span>
        <span class="k">if</span> <span class="n">exist_ra_offset</span><span class="p">:</span>
            <span class="c1"># if RA_OFFSET exists, then check if the ORIG column is there</span>
            <span class="k">if</span> <span class="s1">&#39;RA_OFFSET_ORIG&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fits_table</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;RA_OFFSET_ORIG&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;RA_OFFSET&#39;</span><span class="p">]</span>
                <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;DEC_OFFSET_ORIG&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;DEC_OFFSET&#39;</span><span class="p">]</span>
                <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;FLUX_SCALE_ORIG&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;FLUX_SCALE&#39;</span><span class="p">]</span>

        <span class="c1"># Finally add the cross-correlation offsets</span>
        <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;RA_CROSS_OFFSET&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_off_arcsec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">3600.</span> \
                                        <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_dec_muse</span><span class="p">))</span>
        <span class="n">fits_table</span><span class="p">[</span><span class="s1">&#39;DEC_CROSS_OFFSET&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cross_off_arcsec</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mf">3600.</span>

        <span class="c1"># Writing up</span>
        <span class="n">fits_table</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_output_table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_output_table</span><span class="p">),</span>
                         <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_output_table</span> <span class="o">=</span> <span class="n">name_output_table</span></div>


    <span class="k">def</span> <span class="nf">_check_nima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="p">):</span>
        <span class="n">test_nima</span> <span class="o">=</span> <span class="n">nima</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">test_nima</span><span class="p">:</span>
                <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;nima=</span><span class="si">{</span><span class="n">nima</span><span class="si">}</span><span class="s2"> not within the range &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;allowed by self.nimages (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">test_nima</span>


<div class="viewcode-block" id="AlignMuseDataset.offset_and_compare"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.offset_and_compare">[docs]</a>    <span class="k">def</span> <span class="nf">offset_and_compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">extra_pixel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extra_arcsec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">extra_rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run the offset and comparison for a given image number</span>
<span class="sd">         </span>
<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        nima: int</span>
<span class="sd">            Index of the image to consider</span>
<span class="sd">        extra_pixel: list of 2 floats</span>
<span class="sd">            Offsets in X and Y in pixels to add to the existing</span>
<span class="sd">            guessed offsets</span>
<span class="sd">            IMPORTANT NOTE: extra_pixel will be considered first</span>
<span class="sd">            (before extra_arcsec).</span>
<span class="sd">        extra_arcsec: list of 2 floats</span>
<span class="sd">            Offsets in X and Y in arcsec to add to the existing</span>
<span class="sd">            guessed offsets. Ignored if extra_pixel is given or None</span>
<span class="sd">        extra_rotation: rotation in degrees</span>
<span class="sd">            Angle to rotate the image (in degrees). Ignore if None</span>

<span class="sd">        Additional arguments</span>
<span class="sd">        --------------------</span>
<span class="sd">        threshold: float [0]</span>
<span class="sd">            Threshold to consider when plotting the comparison</span>
<span class="sd">        plot (bool): if True, will plot the comparison</span>
<span class="sd">            If not used, will use the default self.plot</span>
<span class="sd">               * flux comparison (1 to 1)</span>
<span class="sd">               * Map of the flux ratio</span>
<span class="sd">               * Contours of the two scaled maps</span>
<span class="sd">               * Cuts of the division between the 2 maps</span>

<span class="sd">        See also all arguments from self.compare</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_nima</span><span class="p">(</span><span class="n">nima</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># Add the offset from user</span>
        <span class="n">border</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;border&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">)</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;chunk_size&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_extra_offset_ima</span><span class="p">(</span><span class="n">nima</span><span class="o">=</span><span class="n">nima</span><span class="p">,</span> <span class="n">extra_arcsec</span><span class="o">=</span><span class="n">extra_arcsec</span><span class="p">,</span>
                                    <span class="n">extra_pixel</span><span class="o">=</span><span class="n">extra_pixel</span><span class="p">,</span>
                                    <span class="n">extra_rotation</span><span class="o">=</span><span class="n">extra_rotation</span><span class="p">,</span>
                                    <span class="n">border</span><span class="o">=</span><span class="n">border</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">)</span>

        <span class="c1"># Compare contours if plot is set to True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compare_ima</span><span class="p">(</span><span class="n">nima</span><span class="o">=</span><span class="n">nima</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_list_muse_images</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract the name of the muse images</span>
<span class="sd">        and build the list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_muse_images</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">set_of_paths</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">*</span><span class="si">{1}</span><span class="s2">*.fits&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_muse_images</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">suffix_images</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_suffix</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span> <span class="o">=</span> <span class="p">[</span><span class="n">Path</span><span class="p">(</span><span class="n">muse_path</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
                                         <span class="k">for</span> <span class="n">muse_path</span> <span class="ow">in</span> <span class="n">set_of_paths</span><span class="p">]</span>
            <span class="c1"># Sort alphabetically</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="c1"># Subselection if sel_indices_images is given</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sel_indices_images</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sel_indices_images</span><span class="p">]):</span>
                    <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Selection list - sel_indices_images &quot;</span>
                                        <span class="s2">&quot;- does not match image list&quot;</span><span class="p">)</span>
                    <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Ignoring that input sel_indices_images&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newlist</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span>
                               <span class="k">for</span> <span class="n">nima</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sel_indices_images</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span> <span class="o">=</span> <span class="n">newlist</span>

        <span class="c1"># test if 1 or several images</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_muse_images</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name_muse_images</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_muse_images</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name_muse_images</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="s2">&quot;Name of images is not a string or a list, &quot;</span>
                                <span class="s2">&quot;please check input name_muse_images&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Number of images to deal with</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span><span class="p">)</span>

<div class="viewcode-block" id="AlignMuseDataset.open_hdu"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.open_hdu">[docs]</a>    <span class="k">def</span> <span class="nf">open_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open the HDU of the MUSE and reference images</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_open_ref_hdu</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">status_ref</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="s2">&quot;Problem in opening Reference frame, please check input&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">status_muse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_open_muse_nhdu</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">status_muse</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="s2">&quot;Problem in opening MUSE frame, please check input&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="mi">1</span></div>

    <span class="k">def</span> <span class="nf">_open_muse_nhdu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open the MUSE images hdu</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_name_musehdr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{0}{1:03d}</span><span class="s2">.hdr&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_musehdr</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_name_offmusehdr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">{0}{1:03d}</span><span class="s2">.hdr&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_offmusehdr</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_hdulist_muse</span> <span class="o">=</span> <span class="p">[</span><span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span>
            <span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_muse_images</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_muse_hdu</span> <span class="o">=</span> <span class="p">[</span><span class="n">hdu</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                              <span class="k">for</span> <span class="n">hdu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_hdulist_muse</span><span class="p">]</span>
        <span class="c1"># CHANGE to mpdaf WCS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_wcs_muse</span> <span class="o">=</span> <span class="p">[</span><span class="n">WCS</span><span class="p">(</span><span class="n">hdu</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">hdu</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_hdulist_muse</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_dec_muse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">muse_wcs</span><span class="o">.</span><span class="n">get_crval2</span><span class="p">()</span>
                                       <span class="k">for</span> <span class="n">muse_wcs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_wcs_muse</span><span class="p">])</span>
        <span class="c1"># Getting the orientation angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_wcs_rotangles</span> <span class="o">=</span> <span class="p">[</span><span class="n">musewcs</span><span class="o">.</span><span class="n">get_rot</span><span class="p">()</span>
                                   <span class="k">for</span> <span class="n">musewcs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_wcs_muse</span><span class="p">]</span>

        <span class="c1"># Filling in the MJD and DATE OBS keywords for the MUSE images</span>
        <span class="c1"># If not there, will be filled with &quot;None&quot;</span>
        <span class="k">for</span> <span class="n">nima</span><span class="p">,</span> <span class="n">hdu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_hdulist_muse</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">date_names</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_dateobs</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_dateobs</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="n">date_names</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">mjd_names</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_mjdobs</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_mjdobs</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="n">mjd_names</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">tpl_names</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_tplstart</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_tplstart</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="n">tpl_names</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">iexpo_names</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_iexpo</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_iexpo</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="n">iexpo_names</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">dataset_names</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ima_dataset</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="n">dataset_names</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backward_comp</span> <span class="ow">and</span> <span class="n">dataset_names</span><span class="p">[</span><span class="s1">&#39;oldimage&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ima_dataset</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdu</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="n">dataset_names</span><span class="p">[</span><span class="s1">&#39;oldimage&#39;</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ima_dataset</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_muse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_open_ref_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open the reference image hdu</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Open the images</span>
        <span class="n">hdulist_reference</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_reference</span><span class="p">,</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">name_reference</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_hdu</span> <span class="o">=</span> <span class="n">hdulist_reference</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hdu_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_hdu</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="s2">&quot;No data found in extension of reference frame&quot;</span><span class="p">)</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="s2">&quot;Check your input, &quot;</span>
                              <span class="s2">&quot;or change the extention number in input hdu_ext[0]&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="mi">1</span>

<div class="viewcode-block" id="AlignMuseDataset.get_imaref_muse"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.get_imaref_muse">[docs]</a>    <span class="k">def</span> <span class="nf">get_imaref_muse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">muse_hdu</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the ref and input images on the same grid as the given</span>
<span class="sd">        input hdu assuming a given rotation</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        muse_hdu: HDU</span>
<span class="sd">            MUSE hdu file</span>
<span class="sd">        name_musehdr: str</span>
<span class="sd">            name of the muse hdr to save</span>
<span class="sd">        rotation: float</span>
<span class="sd">            Angle in degrees (0).</span>
<span class="sd">        threshold: float</span>
<span class="sd">            Minimum flux to prepare the image (0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ima_ref, ima_muse: arrays</span>
<span class="sd">            Reprojected images</span>

<span class="sd">        Note that the original images are saved in self._temp_input_origmuse and</span>
<span class="sd">        self._temp_input_origref when debug mode is on (self._debug)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">remove_bkg</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;remove_bkg&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">squeeze</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;squeeze&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">border</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;border&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">)</span>
        <span class="n">mask_stars</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;mask_stars&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_threshold</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_threshold</span>

        <span class="c1"># Save hdr if save_hdr is True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_hdr</span><span class="p">:</span>
            <span class="n">name_musehdr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;name_musehdr&quot;</span><span class="p">,</span> <span class="s2">&quot;dummy.hdr&quot;</span><span class="p">)</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">muse_hdu</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">totextfile</span><span class="p">(</span><span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header_folder_name</span><span class="p">,</span>
                                                    <span class="n">name_musehdr</span><span class="p">),</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Projecting the reference image onto the MUSE dataset</span>
        <span class="n">hdu_target</span><span class="p">,</span> <span class="n">proj_ref_hdu</span><span class="p">,</span> <span class="n">diffra_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_reference_hdu</span><span class="p">(</span><span class="n">muse_hdu</span><span class="p">,</span>
                                                                           <span class="n">target_rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span>
                                                                           <span class="n">conversion_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">threshold_convert</span> <span class="o">=</span> <span class="n">threshold</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversion_factor</span>
        <span class="n">ima_ref</span> <span class="o">=</span> <span class="n">flatclean_image</span><span class="p">(</span><span class="n">proj_ref_hdu</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">border</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_range</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">median_window</span><span class="p">,</span>
                                  <span class="n">threshold</span><span class="o">=</span><span class="n">threshold_convert</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="n">squeeze</span><span class="p">,</span>
                                  <span class="n">remove_bkg</span><span class="o">=</span><span class="n">remove_bkg</span><span class="p">)</span>
        <span class="n">ima_muse</span> <span class="o">=</span> <span class="n">flatclean_image</span><span class="p">(</span><span class="n">muse_hdu</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">border</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_range</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">median_window</span><span class="p">,</span>
                                   <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="n">squeeze</span><span class="p">,</span> <span class="n">remove_bkg</span><span class="o">=</span><span class="n">remove_bkg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask_stars</span><span class="p">:</span>
            <span class="n">ima_ref</span> <span class="o">=</span> <span class="n">mask_point_sources</span><span class="p">(</span><span class="n">ima_ref</span><span class="p">)</span>
            <span class="n">ima_muse</span> <span class="o">=</span> <span class="n">mask_point_sources</span><span class="p">(</span><span class="n">ima_muse</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temp_input_origmuse</span> <span class="o">=</span> <span class="n">muse_hdu</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temp_input_origref</span> <span class="o">=</span> <span class="n">proj_ref_hdu</span><span class="o">.</span><span class="n">data</span> <span class="o">*</span> <span class="mf">1.0</span>

        <span class="k">return</span> <span class="n">ima_ref</span><span class="p">,</span> <span class="n">ima_muse</span></div>


<div class="viewcode-block" id="AlignMuseDataset.get_shift_from_pcc_listima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.get_shift_from_pcc_listima">[docs]</a>    <span class="k">def</span> <span class="nf">get_shift_from_pcc_listima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_nima</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run the PCC shift guess on a list of images given by a list</span>
<span class="sd">        of indices</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        list_nima: list of indices for images to process</span>
<span class="sd">            Should be a list. Default is None</span>
<span class="sd">            and all images are processed</span>

<span class="sd">        thhreshold: float [None]</span>
<span class="sd">            minimum value to be used in the phase cross-correlation</span>
<span class="sd">            Flux below that value will be set to 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Starting the PCC shift guess for all images&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">list_nima</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">list_nima</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nima</span> <span class="ow">in</span> <span class="n">list_nima</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_shift_from_pcc_ima</span><span class="p">(</span><span class="n">nima</span><span class="o">=</span><span class="n">nima</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlignMuseDataset.get_shift_from_pcc_ima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.get_shift_from_pcc_ima">[docs]</a>    <span class="k">def</span> <span class="nf">get_shift_from_pcc_ima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run the PCC shift guess for image nima</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        nima: int</span>
<span class="sd">            Index of image</span>
<span class="sd">        threshold: float [None]</span>
<span class="sd">           minimum value to be used in the phase cross-correlation</span>
<span class="sd">           Flux below that value will be set to 0.</span>
<span class="sd">        rotation: float</span>
<span class="sd">           If None, will take the init_rotangle. Otherwise it will take the input value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;PCC for image </span><span class="si">{</span><span class="n">nima</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rotation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_rotangles</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span>

        <span class="c1"># Running shift_from_pcc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcc_off_pixel</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shift_from_pcc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_muse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span>
                                                           <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span>
                                                           <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                                                           <span class="n">name_musehdr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">list_name_musehdr</span><span class="p">[</span>
                                                               <span class="n">nima</span><span class="p">],</span>
                                                           <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcc_off_arcsec</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixel_to_arcsec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_muse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">pcc_off_pixel</span><span class="p">[</span><span class="n">nima</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcc_off_init</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="AlignMuseDataset.get_shift_from_pcc"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.get_shift_from_pcc">[docs]</a>    <span class="k">def</span> <span class="nf">get_shift_from_pcc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">muse_hdu</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find a guess translation using PCC</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        muse_hdu: HDU</span>
<span class="sd">            MUSE hdu file</span>
<span class="sd">        rotation: float</span>
<span class="sd">            Angle in degrees (0).</span>
<span class="sd">        threshold: float</span>
<span class="sd">            Minimum flux to prepare the image (0).</span>
<span class="sd">        name_musehdr: str</span>
<span class="sd">            Name of the muse hdr to save. Optional. Only operational if self.save_hdr is True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xpix_pcc</span>
<span class="sd">        ypix_pcc x and y pixel coordinates of the cross-correlation peak</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ima_ref</span><span class="p">,</span> <span class="n">ima_muse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_imaref_muse</span><span class="p">(</span><span class="n">muse_hdu</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                                                 <span class="n">border</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">remove_bkg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temp_input_pccmuse</span> <span class="o">=</span> <span class="n">ima_muse</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temp_input_pccref</span> <span class="o">=</span> <span class="n">ima_ref</span>

        <span class="n">gt</span> <span class="o">=</span> <span class="n">sppalign</span><span class="o">.</span><span class="n">AlignTranslationPCC</span><span class="p">(</span><span class="n">ima_muse</span><span class="p">,</span> <span class="n">ima_ref</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="c1"># Beware that get_translation from spacepylot return y, x</span>
        <span class="c1"># Hence the ::-1 to reverse it and the minus sign as it is the reverse than done with PCC</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">gt</span><span class="o">.</span><span class="n">get_translation</span><span class="p">(</span><span class="n">split_image</span><span class="o">=</span><span class="mi">2</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="AlignMuseDataset.run_optical_flow"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.run_optical_flow">[docs]</a>    <span class="k">def</span> <span class="nf">run_optical_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_nima</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_rotation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run Optical flow, first with a guess offset and then iterating. The solution</span>
<span class="sd">        is saved as extra offset in the class, and a op_plot instance is created.</span>
<span class="sd">        If save_plot is True, it will save a set of default plots</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        list_nima: list</span>
<span class="sd">            List of indices. If None, will use the default list of all images</span>
<span class="sd">        save_plot : bool</span>
<span class="sd">            Whether to save the optical flow diagnostic plots or not.</span>
<span class="sd">        use_rotation: bool</span>
<span class="sd">            True if you wish to have rotation. False otherwise</span>
<span class="sd">        verbose: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Run the optical flow for all images in list (indices)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">list_nima</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">list_nima</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">)</span>

        <span class="c1"># Use Translation and Rotation or only rotation?</span>
        <span class="k">for</span> <span class="n">nima</span> <span class="ow">in</span> <span class="n">list_nima</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;------- Optical Flow for Image </span><span class="si">{</span><span class="n">nima</span><span class="si">}</span><span class="s2"> -------&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run_optical_flow_ima</span><span class="p">(</span><span class="n">nima</span><span class="o">=</span><span class="n">nima</span><span class="p">,</span> <span class="n">save_plot</span><span class="o">=</span><span class="n">save_plot</span><span class="p">,</span>
                                      <span class="n">use_rotation</span><span class="o">=</span><span class="n">use_rotation</span><span class="p">,</span>
                                      <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlignMuseDataset.run_optical_flow_ima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.run_optical_flow_ima">[docs]</a>    <span class="k">def</span> <span class="nf">run_optical_flow_ima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">save_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_rotation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run Optical flow on image with index nima,</span>
<span class="sd">        first with a guess offset and then iterating. The solution</span>
<span class="sd">        is saved as extra offset in the class, and a op_plot instance is created.</span>
<span class="sd">        If save_plot is True, it will save a set of default plots</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        nima: int</span>
<span class="sd">            Image index.</span>
<span class="sd">        save_plot : bool</span>
<span class="sd">            Whether to save the optical flow diagnostic plots or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterate_on_optical_flow_ima</span><span class="p">(</span><span class="n">nima</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">use_rotation</span><span class="o">=</span><span class="n">use_rotation</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_optical_flow_offset_ima</span><span class="p">(</span><span class="n">nima</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ioff</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op_plots</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">red_blue_before_after</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figures_folder_name</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;opflow_redblue_</span><span class="si">{</span><span class="n">nima</span><span class="si">:</span><span class="s2">03d</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op_plots</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">before_after</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figures_folder_name</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;opflow_beforeafter_</span><span class="si">{</span><span class="n">nima</span><span class="si">:</span><span class="s2">03d</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op_plots</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">illustrate_vector_fields</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figures_folder_name</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;opflow_vectorfield_</span><span class="si">{</span><span class="n">nima</span><span class="si">:</span><span class="s2">03d</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">op_plots</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">before_after_diff_frac</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figures_folder_name</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;opflow_beforeafter_frac_&quot;</span>
                                                           <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nima</span><span class="si">:</span><span class="s2">03d</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span></div>

<div class="viewcode-block" id="AlignMuseDataset.apply_optical_flow_offset_listima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.apply_optical_flow_offset_listima">[docs]</a>    <span class="k">def</span> <span class="nf">apply_optical_flow_offset_listima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_nima</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the optical flow offset as extra pixels offsets and rotation</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        list_nima: list</span>
<span class="sd">            If None, will be initiliased to the default list of indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Apply the optical flow offset as extra user offset - and rotation&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">list_nima</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">list_nima</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nima</span> <span class="ow">in</span> <span class="n">list_nima</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_optical_flow_offset_ima</span><span class="p">(</span><span class="n">nima</span><span class="o">=</span><span class="n">nima</span><span class="p">)</span></div>


<div class="viewcode-block" id="AlignMuseDataset.apply_optical_flow_offset_ima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.apply_optical_flow_offset_ima">[docs]</a>    <span class="k">def</span> <span class="nf">apply_optical_flow_offset_ima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Transfer the value of the optical flow into the extra pixel</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optical_flows</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No optical flow class for image </span><span class="si">{</span><span class="n">nima</span><span class="si">}</span><span class="s2"> -&quot;</span>
                                 <span class="s2">&quot;- run it before applying it&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Apply optical flow offset solution to Image #</span><span class="si">{</span><span class="n">nima</span><span class="si">:</span><span class="s2">03d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Now set up the extra needed offsets as the solution from optical flow</span>
        <span class="c1"># We need to invert Y, X to X, Y (the [::-1]) and use the minus sign</span>
        <span class="c1"># considering optical flow derives the motion of ref to MUSE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_extra_offset_ima</span><span class="p">(</span><span class="n">nima</span><span class="o">=</span><span class="n">nima</span><span class="p">,</span>
                                    <span class="n">extra_pixel</span><span class="o">=-</span> <span class="bp">self</span><span class="o">.</span><span class="n">optical_flows</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">translation</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="n">extra_rotation</span><span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">optical_flows</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">rotation_deg</span><span class="p">)</span>
        <span class="c1"># Initialise the plot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op_plots</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_plot_optical_flow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optical_flows</span><span class="p">[</span><span class="n">nima</span><span class="p">])</span></div>


<div class="viewcode-block" id="AlignMuseDataset.iterate_on_optical_flow_ima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.iterate_on_optical_flow_ima">[docs]</a>    <span class="k">def</span> <span class="nf">iterate_on_optical_flow_ima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">niter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">use_rotation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate solution using the optical flow guess</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        nima: int</span>
<span class="sd">            Index of image to consider</span>
<span class="sd">        niter: int</span>
<span class="sd">            Number of iterations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optical flow with </span><span class="si">{</span><span class="n">niter</span><span class="si">}</span><span class="s2"> iterations for Image </span><span class="si">{</span><span class="n">nima</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">list_guess_key</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;guess_rotation&quot;</span><span class="p">,</span> <span class="s2">&quot;guess_offset_pixel&quot;</span><span class="p">,</span> <span class="s2">&quot;guess_offset_arcsec&quot;</span><span class="p">]</span>
        <span class="n">given_guess</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">guess_key</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">for</span> <span class="n">guess_key</span> <span class="ow">in</span> <span class="n">list_guess_key</span><span class="p">)</span>
        <span class="n">reset_opf</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;reset_optical_flow&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optical_flows</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">reset_opf</span> <span class="ow">or</span> <span class="n">given_guess</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_optical_flow_ima</span><span class="p">(</span><span class="n">nima</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;homography_method&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">homography_method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;homography_method&quot;</span><span class="p">,</span> <span class="n">transform</span><span class="o">.</span><span class="n">EuclideanTransform</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_rotation</span><span class="p">:</span>
                <span class="n">homography_method</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">EuclideanTransform</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">homography_method</span> <span class="o">=</span> <span class="n">TranslationTransform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optical_flows</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">get_iterate_translation_rotation</span><span class="p">(</span><span class="n">niter</span><span class="p">,</span>
                                                                  <span class="n">homography_method</span><span class="o">=</span><span class="n">homography_method</span><span class="p">)</span></div>


<div class="viewcode-block" id="AlignMuseDataset.iterate_on_optical_flow_listima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.iterate_on_optical_flow_listima">[docs]</a>    <span class="k">def</span> <span class="nf">iterate_on_optical_flow_listima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_nima</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_rotation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run the iteration for the optical flow on a list of images</span>
<span class="sd">        given by a list of indices</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        list_nima: list of indices for images to process</span>
<span class="sd">            Should be a list. Default is None</span>
<span class="sd">            and all images are processed</span>

<span class="sd">        niter: int</span>
<span class="sd">            Number of iterations. Optional. If  not provided, will use the</span>
<span class="sd">            default in self.iterate_on_optical_flow_ima</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Iteration the Optical Flow solution on all images&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">list_nima</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">list_nima</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nima</span> <span class="ow">in</span> <span class="n">list_nima</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iterate_on_optical_flow_ima</span><span class="p">(</span><span class="n">nima</span><span class="o">=</span><span class="n">nima</span><span class="p">,</span> <span class="n">use_rotation</span><span class="o">=</span><span class="n">use_rotation</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="AlignMuseDataset.init_optical_flow_listima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.init_optical_flow_listima">[docs]</a>    <span class="k">def</span> <span class="nf">init_optical_flow_listima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_nima</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise the optical flow on a list of images</span>
<span class="sd">        given by a list of indices</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        list_nima: list of indices for images to process</span>
<span class="sd">            Should be a list. Default is None</span>
<span class="sd">            and all images are processed</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Initiliase the Optical Flow on all images&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">list_nima</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">list_nima</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nima</span> <span class="ow">in</span> <span class="n">list_nima</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_optical_flow_ima</span><span class="p">(</span><span class="n">nima</span><span class="o">=</span><span class="n">nima</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="AlignMuseDataset.init_optical_flow_ima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.init_optical_flow_ima">[docs]</a>    <span class="k">def</span> <span class="nf">init_optical_flow_ima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guess_offset_pixel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">guess_offset_arcsec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guess_rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">force_pcc_guess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">provide_header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialise the optical flow using the current image with index nima</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        nima: int</span>
<span class="sd">            Index of image</span>
<span class="sd">        threshold: float</span>
<span class="sd">            Minimum flux to consider</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Forcing a pcc guess if all guess are None</span>
        <span class="c1"># WARNING: we need to set the offset as Y, X to pass it on optical flow</span>
        <span class="k">if</span> <span class="n">guess_offset_pixel</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">guess_offset_arcsec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Force a PCC guess</span>
            <span class="k">if</span> <span class="n">force_pcc_guess</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_shift_from_pcc_ima</span><span class="p">(</span><span class="n">nima</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                <span class="n">guess_offset_pixel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcc_off_pixel</span><span class="p">[</span><span class="n">nima</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Or use the already defined one</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">guess_offset_pixel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_off_pixel</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span>

        <span class="c1"># Make sure guess_offset_pixel is there if arcsec are given</span>
        <span class="n">guess_offset_pixel</span><span class="p">,</span> <span class="n">guess_offset_arcsec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_offset_pixel_arcsec</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_muse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span> <span class="n">guess_offset_pixel</span><span class="p">,</span> <span class="n">guess_offset_arcsec</span><span class="p">)</span>

        <span class="c1"># Retrofitting the guessed values into the init values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_off_pixel</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">guess_offset_pixel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_off_arcsec</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">guess_offset_arcsec</span>

        <span class="k">if</span> <span class="n">guess_rotation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">guess_rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_rotangles</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span>

        <span class="c1"># Do the alignment and get the off_muse and proj_ref using those guess offset</span>
        <span class="n">hdu_off_muse</span><span class="p">,</span> <span class="n">hdu_proj_ref</span><span class="p">,</span> <span class="n">diffra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_alignment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_muse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span>
                                                                   <span class="n">total_off_pixel</span><span class="o">=</span><span class="n">guess_offset_pixel</span><span class="p">,</span>
                                                                   <span class="n">total_off_arcsec</span><span class="o">=</span><span class="n">guess_offset_arcsec</span><span class="p">,</span>
                                                                   <span class="n">total_rotangle</span><span class="o">=</span><span class="n">guess_rotation</span><span class="p">,</span>
                                                                   <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Used grid with initial Offset / Rotation = &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">guess_offset_pixel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">8.4f</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">guess_offset_pixel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">8.4f</span><span class="si">}</span><span class="s2"> [PIX] &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;/ </span><span class="si">{</span><span class="n">guess_rotation</span><span class="si">}</span><span class="s2"> [DEG]&quot;</span><span class="p">)</span>

        <span class="c1"># Calling optical flow initialisation</span>
        <span class="k">if</span> <span class="n">provide_header</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">hdu_off_muse</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Initialise optical flow with the corresponding HDU</span>
        <span class="c1"># All guesses should not be 0, since they have been processed above</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optical_flows</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_optical_flow_hdu</span><span class="p">(</span><span class="n">hdu_off_muse</span><span class="p">,</span>
                                                              <span class="n">rotation</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                                                              <span class="n">guess_translation</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
                                                              <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlignMuseDataset.init_optical_flow_hdu"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.init_optical_flow_hdu">[docs]</a>    <span class="k">def</span> <span class="nf">init_optical_flow_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">muse_hdu</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">guess_translation</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span>
                              <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the optical flow for this hdu</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        muse_hdu: HDU</span>
<span class="sd">            Muse HDU input</span>
<span class="sd">        rotation: float</span>
<span class="sd">            Input rotation</span>
<span class="sd">        threshold: float</span>
<span class="sd">            Minimum flux to consider in the image</span>
<span class="sd">        guess_translation: tuple of 2 floats</span>
<span class="sd">            Guess offset in X and Y, e.g., (0., 0.)</span>
<span class="sd">        name_musehdr: str</span>
<span class="sd">            Name of hdr in case those are saved (self.save_hdr is True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Getting the images. Note that border must be 0 as otherwise you will need to change</span>
        <span class="c1"># the WCS (header passed to AlignOpticalFlow</span>
        <span class="n">ima_ref</span><span class="p">,</span> <span class="n">ima_muse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_imaref_muse</span><span class="p">(</span><span class="n">muse_hdu</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">border</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                                 <span class="n">remove_bkg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temp_input_opflow_muse</span> <span class="o">=</span> <span class="n">ima_muse</span> <span class="o">*</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temp_input_opflow_ref</span> <span class="o">=</span> <span class="n">ima_ref</span> <span class="o">*</span> <span class="mf">1.0</span>

        <span class="c1"># WARNING: we pass on Y, X hence the [::-1] in the guess_translation parameter</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initialising Optical Flow, with guess_translation (x,y): &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">guess_translation</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sppalign</span><span class="o">.</span><span class="n">AlignOpticalFlow</span><span class="p">(</span><span class="n">ima_muse</span><span class="p">,</span> <span class="n">ima_ref</span><span class="p">,</span>
                                         <span class="n">guess_translation</span><span class="o">=</span><span class="n">guess_translation</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                         <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
                                         <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>


<div class="viewcode-block" id="AlignMuseDataset.find_cross_peak_ima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.find_cross_peak_ima">[docs]</a>    <span class="k">def</span> <span class="nf">find_cross_peak_ima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find the cross correlation peak and get the x and y shifts</span>
<span class="sd">        for a given image, given its index nima</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        nima: int</span>
<span class="sd">           Index of the image</span>
<span class="sd">        threshold: float</span>
<span class="sd">           Minimum flux for the cross-correlation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cross-correlation for image </span><span class="si">{</span><span class="n">nima</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cross_off_pixel</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_cross_peak</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_muse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span>
                                                          <span class="n">rotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">init_rotangles</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span>
                                                          <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                                                          <span class="n">name_musehdr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">list_name_musehdr</span><span class="p">[</span><span class="n">nima</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cross_off_arcsec</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixel_to_arcsec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_muse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">cross_off_pixel</span><span class="p">[</span><span class="n">nima</span><span class="p">])</span></div>

<div class="viewcode-block" id="AlignMuseDataset.find_cross_peak_listima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.find_cross_peak_listima">[docs]</a>    <span class="k">def</span> <span class="nf">find_cross_peak_listima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">list_nima</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Run the cross correlation peaks on all MUSE images</span>
<span class="sd">        Derive the self.cross_off_pixel/arcsec parameters</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        list_nima: list</span>
<span class="sd">            list of indices for images to process Should be a list. Default is None</span>
<span class="sd">            and all images are processed</span>
<span class="sd">        threshold: float [None]</span>
<span class="sd">            minimum flux to be used in the cross-correlation</span>
<span class="sd">            Flux below that value will be set to 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="s2">&quot;Starting the cross-correlation for all images&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">list_nima</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">list_nima</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nima</span> <span class="ow">in</span> <span class="n">list_nima</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">find_cross_peak_ima</span><span class="p">(</span><span class="n">nima</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlignMuseDataset.find_cross_peak"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.find_cross_peak">[docs]</a>    <span class="k">def</span> <span class="nf">find_cross_peak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">muse_hdu</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Aligns the MUSE HDU to a reference HDU</span>
<span class="sd">         </span>
<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        muse_hdu: astropy.io.fits hdu</span>
<span class="sd">            MUSE hdu file</span>
<span class="sd">        name_musehdr: str</span>
<span class="sd">            name of the muse hdr to save</span>
<span class="sd">        rotation: float</span>
<span class="sd">            Angle in degrees (0).</span>
<span class="sd">        threshold: minimum flux to be used in the cross-correlation</span>
<span class="sd">            Flux below that value will be set to 0.</span>
<span class="sd">            Default is 0.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xpix_cross</span>
<span class="sd">        ypix_cross: x and y pixel coordinates of the cross-correlation peak</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ima_ref</span><span class="p">,</span> <span class="n">ima_muse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_imaref_muse</span><span class="p">(</span><span class="n">muse_hdu</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_corr</span><span class="p">:</span>
            <span class="n">shifts</span><span class="p">,</span> <span class="n">shift_errors</span><span class="p">,</span> <span class="n">phasediff</span> <span class="o">=</span> <span class="n">phase_cross_correlation</span><span class="p">(</span><span class="n">ima_ref</span><span class="p">,</span> <span class="n">ima_muse</span><span class="p">,</span>
                                                                      <span class="n">upsample_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_subsamp</span><span class="p">)</span>
            <span class="n">xpix_cross</span> <span class="o">=</span> <span class="n">shifts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ypix_cross</span> <span class="o">=</span> <span class="n">shifts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Cross-correlate the images</span>
            <span class="n">ccor</span> <span class="o">=</span> <span class="n">correlate</span><span class="p">(</span><span class="n">ima_ref</span><span class="p">,</span> <span class="n">ima_muse</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_temp_ima_muse_tocc</span> <span class="o">=</span> <span class="n">ima_muse</span> <span class="o">*</span> <span class="mf">1.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_temp_ima_ref_tocc</span> <span class="o">=</span> <span class="n">ima_ref</span> <span class="o">*</span> <span class="mf">1.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_temp_cc</span> <span class="o">=</span> <span class="n">ccor</span> <span class="o">*</span> <span class="mf">1.0</span>

            <span class="c1"># Find peak of cross-correlation</span>
            <span class="n">maxy</span><span class="p">,</span> <span class="n">maxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ccor</span><span class="p">),</span>
                                          <span class="n">ccor</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># Extract a window around it</span>
            <span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subim_window</span>
            <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">window</span> <span class="o">+</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">window</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">maxy</span><span class="p">),</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">window</span> <span class="o">+</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">window</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">maxx</span><span class="p">))</span>
            <span class="n">subim</span> <span class="o">=</span> <span class="n">ccor</span><span class="p">[</span><span class="n">y</span> <span class="o">%</span> <span class="n">ccor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span> <span class="o">%</span> <span class="n">ccor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">subim</span> <span class="o">-=</span> <span class="n">subim</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">subim</span><span class="p">)</span>
            <span class="n">smaxy</span><span class="p">,</span> <span class="n">smaxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">subim</span><span class="p">),</span>
                                            <span class="n">subim</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># Fit a 2D Gaussian to that peak</span>
            <span class="n">gauss_init</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Gaussian2D</span><span class="p">(</span><span class="n">amplitude</span><span class="o">=</span><span class="n">mx</span><span class="p">,</span>
                                           <span class="n">x_mean</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">smaxx</span><span class="p">],</span>
                                           <span class="n">y_mean</span><span class="o">=</span><span class="n">y</span><span class="p">[</span><span class="n">smaxy</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                           <span class="n">x_stddev</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                           <span class="n">y_stddev</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                           <span class="n">theta</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">fitter</span> <span class="o">=</span> <span class="n">fitting</span><span class="o">.</span><span class="n">LevMarLSQFitter</span><span class="p">()</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">fitter</span><span class="p">(</span><span class="n">gauss_init</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">y</span><span class="p">),</span>
                            <span class="n">y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                            <span class="n">subim</span><span class="p">)</span>

            <span class="c1"># Update Astrometry</span>
            <span class="c1"># Beware, the sign was changed here and is now ok</span>
            <span class="n">xpix_cross</span> <span class="o">=</span> <span class="n">ccor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">params</span><span class="o">.</span><span class="n">x_mean</span>
            <span class="n">ypix_cross</span> <span class="o">=</span> <span class="n">ccor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">params</span><span class="o">.</span><span class="n">y_mean</span>

        <span class="k">return</span> <span class="n">xpix_cross</span><span class="p">,</span> <span class="n">ypix_cross</span></div>

<div class="viewcode-block" id="AlignMuseDataset.save_image"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.save_image">[docs]</a>    <span class="k">def</span> <span class="nf">save_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newfits_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save the newly determined hdu</span>
<span class="sd">         </span>
<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        newfits_name: str</span>
<span class="sd">            Name of the fits file to be used</span>
<span class="sd">        nima: int [0]</span>
<span class="sd">            Index of the image to save</span>

<span class="sd">        Creates</span>
<span class="sd">        -------</span>
<span class="sd">        A new fits file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;list_offmuse_hdu&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">newfits_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">newfits_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="s2">&quot;.fits&quot;</span><span class="p">,</span> <span class="s2">&quot;_shift.fits&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_offmuse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">newfits_name</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_error</span><span class="p">(</span><span class="s2">&quot;There are not yet any new hdu to save&quot;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_align_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdu_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hdu_to_align</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">target_rotation</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">to_align_rotation</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
              <span class="n">conversion_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Project an to be aligned hdu onto the input hdu</span>
<span class="sd">        Hidden function, as only used internally</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        hdu_target: HDU [None]</span>
<span class="sd">            Target hdu (on to which to project)</span>
<span class="sd">        hdu_to_align: HDU [None]</span>
<span class="sd">             Hdu to be aligned</span>
<span class="sd">        target_rotation: float [0]</span>
<span class="sd">            Rotation angle in degrees of the target hdu</span>
<span class="sd">        to_align_rotation: float [0]</span>
<span class="sd">            Rotation angle in degrees of the to be aligned hdu</span>
<span class="sd">        conversion_factor: float</span>
<span class="sd">            If None, will use the self.conversion_factor parameter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hdu_repr: HDU</span>
<span class="sd">            Reprojected HDU. None if nothing is provided</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">conversion_factor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">conversion_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversion_factor</span>

        <span class="k">return</span> <span class="n">align_hdu</span><span class="p">(</span><span class="n">hdu_target</span><span class="o">=</span><span class="n">hdu_target</span><span class="p">,</span> <span class="n">hdu_to_align</span><span class="o">=</span><span class="n">hdu_to_align</span><span class="p">,</span>
                         <span class="n">target_rotation</span><span class="o">=</span><span class="n">target_rotation</span><span class="p">,</span> <span class="n">to_align_rotation</span><span class="o">=</span><span class="n">to_align_rotation</span><span class="p">,</span>
                         <span class="n">conversion_factor</span><span class="o">=</span><span class="n">conversion_factor</span><span class="p">,</span> <span class="n">use_mpdaf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_mpdaf</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_align_reference_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdu_target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target_rotation</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                             <span class="n">ref_rotation</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">conversion_factor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Project the reference image onto the target hdu</span>
<span class="sd">        Hidden function, as only used internally</span>
<span class="sd">         </span>
<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        hdu_target: HDU [None]</span>
<span class="sd">            Input hdu</span>
<span class="sd">        target_rotation: float [0]</span>
<span class="sd">            Target rotation angle in degrees</span>
<span class="sd">        ref_rotation: float [0]</span>
<span class="sd">            Rotation of the reference image</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hdu_repr: HDU</span>
<span class="sd">            Reprojected HDU. None if nothing is provided</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_hdu</span><span class="p">(</span><span class="n">hdu_target</span><span class="o">=</span><span class="n">hdu_target</span><span class="p">,</span> <span class="n">hdu_to_align</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_hdu</span><span class="p">,</span>
                               <span class="n">target_rotation</span><span class="o">=</span><span class="n">target_rotation</span><span class="p">,</span> <span class="n">to_align_rotation</span><span class="o">=</span><span class="n">ref_rotation</span><span class="p">,</span>
                               <span class="n">conversion_factor</span><span class="o">=</span><span class="n">conversion_factor</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_total_rotangles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_rotangles</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_rotangles</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_total_off_pixel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_off_pixel</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_off_pixel</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_total_off_arcsec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_off_arcsec</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_off_arcsec</span>

    <span class="k">def</span> <span class="nf">_set_extra_offset_ima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">extra_pixel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extra_arcsec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">extra_rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add user offset in pixel and transform into arcseconds</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        extra_pixel: list of 2 floats [0,0]</span>
<span class="sd">            Extra offsets (x,y) in pixels</span>
<span class="sd">        extra_arsec: list of 2 floats [0,0]</span>
<span class="sd">            Extra offsets (x,y) in arcsec if extra_pixel is not provided</span>
<span class="sd">        extra_rotation: rotation in degrees [0]</span>
<span class="sd">        nima: int</span>
<span class="sd">            Index of image to consider</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add this to the extra_off arrays</span>
        <span class="k">if</span> <span class="n">extra_pixel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extra_arcsec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Transforming the arc into pix</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">extra_off_arcsec</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">extra_arcsec</span>
                <span class="c1"># Transforming into pixels - would be better with setter</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">extra_off_pixel</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">arcsec_to_pixel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_muse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span> <span class="n">extra_arcsec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extra_off_pixel</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">extra_pixel</span>
            <span class="c1"># Transforming into arcsec - would be better with setter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extra_off_arcsec</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixel_to_arcsec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_muse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span> <span class="n">extra_pixel</span><span class="p">)</span>

        <span class="c1"># And the rotation angle in degrees</span>
        <span class="k">if</span> <span class="n">extra_rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extra_rotangles</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">extra_rotation</span>


<div class="viewcode-block" id="AlignMuseDataset.apply_extra_offset_ima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.apply_extra_offset_ima">[docs]</a>    <span class="k">def</span> <span class="nf">apply_extra_offset_ima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">extra_pixel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extra_arcsec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">extra_rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shift image with index nima with the total offset</span>
<span class="sd">        after adding any extra given offset</span>
<span class="sd">        This does not return anything but could in principle</span>
<span class="sd">        if using the output of the self.shift</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        nima: int</span>
<span class="sd">            Index of image to consider</span>
<span class="sd">        extra_pixel: list of 2 floats</span>
<span class="sd">            Extra offsets (x,y) in pixels. If None, nothing is applied</span>
<span class="sd">        extra_arcsec: list of 2 floats</span>
<span class="sd">            Extra offsets (x,y) in arcsec if extra_pixel is not provided</span>
<span class="sd">            If None, nothing is applied</span>
<span class="sd">        extra_rotation: float</span>
<span class="sd">            Rotation in degrees. If None, no new extra offset is applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add this to the extra_off arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_extra_offset_ima</span><span class="p">(</span><span class="n">nima</span><span class="o">=</span><span class="n">nima</span><span class="p">,</span> <span class="n">extra_arcsec</span><span class="o">=</span><span class="n">extra_arcsec</span><span class="p">,</span> <span class="n">extra_pixel</span><span class="o">=</span><span class="n">extra_pixel</span><span class="p">,</span>
                                    <span class="n">extra_rotation</span><span class="o">=</span><span class="n">extra_rotation</span><span class="p">)</span>

        <span class="c1"># Actually apply the alignment to the image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_alignment_ima</span><span class="p">(</span><span class="n">nima</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_apply_alignment_ima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply alignment for image with index nima</span>

<span class="sd">        Input</span>
<span class="sd">        ----</span>
<span class="sd">        nima: int</span>
<span class="sd">            Index of image. Default is 0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Call the alignment given the input nima image</span>
        <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[#</span><span class="si">{</span><span class="n">nima</span><span class="si">:</span><span class="s2">03d</span><span class="si">}</span><span class="s2">] --- Regridding Image &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">list_name_museimages</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="si">}</span><span class="s2"> ---&quot;</span><span class="p">)</span>
        <span class="n">hdu_offmuse</span><span class="p">,</span> <span class="n">hdu_projref</span><span class="p">,</span> <span class="n">diffra</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_alignment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_muse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span>
            <span class="n">total_off_pixel</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_total_off_pixel</span><span class="p">[</span><span class="n">nima</span><span class="p">],</span> <span class="n">total_rotangle</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_total_rotangles</span><span class="p">[</span><span class="n">nima</span><span class="p">])</span>

        <span class="c1"># Creating a new Primary HDU and its WCS with the input data, and the new Header</span>
        <span class="c1"># This HDU has now been offset using the total offsets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_offmuse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdu_offmuse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_wcs_offmuse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="n">hdu_offmuse</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
        <span class="c1"># Saving the projected reference hdu and its WCS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_proj_refhdu</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">hdu_projref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_wcs_proj_refhdu</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">WCS</span><span class="p">(</span><span class="n">hdu_projref</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

        <span class="c1"># Writing this up in an ascii file for record purposes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_hdr</span><span class="p">:</span>
             <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_offmuse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">totextfile</span><span class="p">(</span><span class="n">joinpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header_folder_name</span><span class="p">,</span>
                                                                        <span class="bp">self</span><span class="o">.</span><span class="n">list_name_offmusehdr</span><span class="p">[</span><span class="n">nima</span><span class="p">]),</span>
                                                               <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Getting the normalisation factors using those last projections</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ima_polypar</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_normfactor_ima</span><span class="p">(</span><span class="n">nima</span><span class="o">=</span><span class="n">nima</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Saving the normalisation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_polypar_ima</span><span class="p">(</span><span class="n">nima</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ima_polypar</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sort_offset_pixel_arcsec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdu</span><span class="p">,</span> <span class="n">offset_pixel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset_arcsec</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        hdu: HDU</span>
<span class="sd">        offset_pixel: tuple of float</span>
<span class="sd">        offset_arcsec: tuple of float</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        offset_pixel, offset_arsec</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Using input offset or total</span>
        <span class="k">if</span> <span class="n">offset_pixel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">offset_arcsec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">offset_pixel</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
                <span class="n">offset_arcsec</span> <span class="o">=</span> <span class="n">pixel_to_arcsec</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">offset_pixel</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offset_pixel</span> <span class="o">=</span> <span class="n">arcsec_to_pixel</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">offset_arcsec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offset_arcsec</span> <span class="o">=</span> <span class="n">pixel_to_arcsec</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">offset_pixel</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">offset_pixel</span><span class="p">,</span> <span class="n">offset_arcsec</span>

    <span class="k">def</span> <span class="nf">_apply_alignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdu</span><span class="p">,</span> <span class="n">total_off_pixel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">total_off_arcsec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">total_rotangle</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create New HDU after shifting it with the right offset</span>
<span class="sd">        (only considering image with index nima)</span>
<span class="sd">         </span>
<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        hdu : HDU</span>
<span class="sd">            Input HDU of image to offset</span>
<span class="sd">        nima: int</span>
<span class="sd">            Index of image to consider</span>
<span class="sd">        </span>
<span class="sd">        Does not return anything, but could in principle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a new Header</span>
        <span class="n">newhdr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">hdu</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

        <span class="c1"># Using input offset or total</span>
        <span class="n">total_off_pixel</span><span class="p">,</span> <span class="n">total_off_arcsec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_offset_pixel_arcsec</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">total_off_pixel</span><span class="p">,</span>
                                                                           <span class="n">total_off_arcsec</span><span class="p">)</span>

        <span class="c1"># Shift the HDU in X and Y</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;verbose&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;       Offset   [PIXELS]: </span><span class="si">{</span><span class="n">total_off_pixel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">8.4f</span><span class="si">}</span><span class="s2">&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">total_off_pixel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">8.4f</span><span class="si">}</span><span class="s2">  /  &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;[ARCSEC]: </span><span class="si">{</span><span class="n">total_off_arcsec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">8.4f</span><span class="si">}</span><span class="s2">&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">total_off_arcsec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">8.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;       Rotation [DEGREE]: </span><span class="si">{</span><span class="n">total_rotangle</span><span class="si">:</span><span class="s2">8.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Shifting the CRPIX values in the header</span>
        <span class="n">newhdr</span><span class="p">[</span><span class="s1">&#39;CRPIX1&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">total_off_pixel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">newhdr</span><span class="p">[</span><span class="s1">&#39;CRPIX2&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">total_off_pixel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Creating a new Primary HDU with the input data, and the new Header</span>
        <span class="c1"># This HDU has now been offset using the total offsets</span>
        <span class="n">hdu_offmuse</span> <span class="o">=</span> <span class="n">pyfits</span><span class="o">.</span><span class="n">PrimaryHDU</span><span class="p">(</span><span class="n">hdu</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">newhdr</span><span class="p">)</span>

        <span class="c1"># Reprojecting the Reference image onto the new MUSE frame</span>
        <span class="n">hdu_target</span><span class="p">,</span> <span class="n">hdu_projref</span><span class="p">,</span> <span class="n">diffra</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_align_reference_hdu</span><span class="p">(</span><span class="n">hdu_target</span><span class="o">=</span><span class="n">hdu_offmuse</span><span class="p">,</span> <span class="n">target_rotation</span><span class="o">=</span><span class="n">total_rotangle</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hdu_offmuse</span><span class="p">,</span> <span class="n">hdu_projref</span><span class="p">,</span> <span class="n">diffra</span>

<div class="viewcode-block" id="AlignMuseDataset.get_normfactor_ima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.get_normfactor_ima">[docs]</a>    <span class="k">def</span> <span class="nf">get_normfactor_ima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">median_filter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">border</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">convolve_muse</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                           <span class="n">convolve_reference</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the normalisation factor for shifted and projected images. This function only </span>
<span class="sd">        consider the input image given by index nima and the reference image (after</span>
<span class="sd">        projection).</span>
<span class="sd">         </span>
<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        nima: int</span>
<span class="sd">            Index of image to consider</span>
<span class="sd">        median_filter: bool</span>
<span class="sd">            If True, will median filter</span>
<span class="sd">        convolve_muse: float [0]</span>
<span class="sd">            Will convolve the image with index nima</span>
<span class="sd">            with a gaussian with that sigma. 0 means no convolution</span>
<span class="sd">        convolve_reference: float [0]</span>
<span class="sd">            Will convolve the reference image</span>
<span class="sd">            with a gaussian with that sigma. 0 means no convolution</span>
<span class="sd">        border: int</span>
<span class="sd">            Number of pixels to crop</span>
<span class="sd">        threshold: float [None]</span>
<span class="sd">            Threshold for the input image flux to consider</span>
<span class="sd">        chunk_size: int</span>
<span class="sd">            Size of chunks to consider for chunk statistics (polynomial normalisation)</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data: 2d array</span>
<span class="sd">        refdata: 2d array</span>
<span class="sd">            The 2 arrays (input, reference) after processing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;threshold&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ima_threshold</span><span class="p">[</span><span class="n">nima</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">get_normfactor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_offmuse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_proj_refhdu</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                              <span class="n">convolve_data1</span><span class="o">=</span><span class="n">convolve_muse</span><span class="p">,</span> <span class="n">convolve_data2</span><span class="o">=</span><span class="n">convolve_reference</span><span class="p">,</span>
                              <span class="n">median_filter</span><span class="o">=</span><span class="n">median_filter</span><span class="p">,</span> <span class="n">border</span><span class="o">=</span><span class="n">border</span><span class="p">,</span>
                              <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span></div>


<div class="viewcode-block" id="AlignMuseDataset.save_polypar_ima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.save_polypar_ima">[docs]</a>    <span class="k">def</span> <span class="nf">save_polypar_ima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saving the input values into the fixed arrays for the polynomial</span>

<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        beta: list/array of 2 floats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">beta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ima_background</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ima_norm_factors</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="AlignMuseDataset.compare_ima"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.compare_ima">[docs]</a>    <span class="k">def</span> <span class="nf">compare_ima</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nima</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nima_museref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">convolve_muse</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">convolve_reference</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        </span>
<span class="sd">        Input</span>
<span class="sd">        -----</span>
<span class="sd">        nima: int</span>
<span class="sd">            Index of input image</span>
<span class="sd">        nima_museref: int</span>
<span class="sd">            Index of second input image for the reference. Default is None, hence ignored</span>
<span class="sd">            and the default reference image will be used.</span>
<span class="sd">        convolve_muse: float</span>
<span class="sd">            Sigma of the gaussian to convolve the input images. Default is 0 (no convolution)</span>
<span class="sd">        convolve_reference: float</span>
<span class="sd">            Sigma of the gaussian to convolve the reference. Default is 0 (no convolution)</span>
<span class="sd">        threshold_muse: float</span>
<span class="sd">            Minimum value to consider in the input images</span>

<span class="sd">        Creates</span>
<span class="sd">        -------</span>
<span class="sd">        Plots which compare the two input datasets as defined by the indices</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Getting the first MUSE image (aligned)</span>
        <span class="n">musehdu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_offmuse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temp_prealigned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_muse_hdu</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>

        <span class="c1"># Getting data from the MUSE ref image if one is given</span>
        <span class="n">museref</span> <span class="o">=</span> <span class="n">nima_museref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">museref</span><span class="p">:</span>
            <span class="n">refhdu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_offmuse_hdu</span><span class="p">[</span><span class="n">nima_museref</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">refhdu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_proj_refhdu</span><span class="p">[</span><span class="n">nima</span><span class="p">]</span>

        <span class="n">threshold_muse</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;threshold_muse&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ima_threshold</span><span class="p">[</span><span class="n">nima</span><span class="p">])</span>

        <span class="n">musedata</span><span class="p">,</span> <span class="n">refdata</span><span class="p">,</span> <span class="n">polypar</span> <span class="o">=</span> <span class="n">get_normfactor</span><span class="p">(</span><span class="n">musehdu</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">refhdu</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
                                                    <span class="n">convolve_data1</span><span class="o">=</span><span class="n">convolve_muse</span><span class="p">,</span>
                                                    <span class="n">convolve_data2</span><span class="o">=</span><span class="n">convolve_reference</span><span class="p">,</span>
                                                    <span class="n">threshold</span><span class="o">=</span><span class="n">threshold_muse</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">data1</span><span class="o">=</span><span class="n">musedata</span><span class="p">,</span> <span class="n">data2</span><span class="o">=</span><span class="n">refdata</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">musehdu</span><span class="o">.</span><span class="n">header</span><span class="p">,</span>
                     <span class="n">suffix_fig</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nima</span><span class="si">:</span><span class="s2">03d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="AlignMuseDataset.compare"><a class="viewcode-back" href="../../api/pymusepipe.html#pymusepipe.align_pipe.AlignMuseDataset.compare">[docs]</a>    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">start_nfig</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nlevels</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">convolve_data1</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">convolve_data2</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                <span class="n">showcontours</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showcuts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shownormalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">showdiff</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">median_filter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ncuts</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">percentage</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span>
                <span class="n">suffix_fig</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compare the projected reference and MUSE image</span>
<span class="sd">        by plotting the contours, the difference and vertical/horizontal cuts.</span>
<span class="sd">         </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data1:</span>
<span class="sd">        data2: 2d np.arrays</span>
<span class="sd">            Array to compare</span>
<span class="sd">        header: Header</span>
<span class="sd">            If provided, will be use to get the WCS in the plots. Default is None (ignored).</span>
<span class="sd">        polypar: ODR result</span>
<span class="sd">            If None, it will be recalculated</span>
<span class="sd">        showcontours: bool [True]</span>
<span class="sd">        showcuts: bool [True]</span>
<span class="sd">        shownormalise: bool [True]</span>
<span class="sd">        showdiff: bool [True]</span>
<span class="sd">            All options corresponding to 1 specific plot. By default</span>
<span class="sd">            show them all (all True)</span>
<span class="sd">        ncuts: int [5]</span>
<span class="sd">            Number of vertical / horizontal cuts along the ratio</span>
<span class="sd">            between the 2 maps to be shown (&quot;cuts&quot;)</span>
<span class="sd">        percentage: float [5]</span>
<span class="sd">            Used to compute which percentile to show</span>
<span class="sd">        start_nfig: int [1]</span>
<span class="sd">            Number of the matplotlib Figure to start with</span>
<span class="sd">        nlevels: int [10]</span>
<span class="sd">            Number of levels for the contour plots</span>
<span class="sd">        levels: list of float [None]</span>
<span class="sd">            Specific list of levels if any (default is None)</span>
<span class="sd">        convolve_data1: float [0]</span>
<span class="sd">            If not 0, will convolve with a gaussian of that sigma</span>
<span class="sd">        convolve_data2: float [0]</span>
<span class="sd">            If not 0, will convolve the reference image</span>
<span class="sd">            with a gaussian of that sigma</span>
<span class="sd">        savefig (bool): False</span>
<span class="sd">            If True, will save the figure into a png</span>
<span class="sd">        suffix_fig: str</span>
<span class="sd">            Suffix name to add to the figure filenames</span>

<span class="sd">        Makes a maximum of 4 figures</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">border</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;border&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">border</span><span class="p">)</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;chunk_size&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="n">savefig</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;savefig&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;threshold&quot;</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>

        <span class="c1"># Getting the data</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">polypar</span> <span class="o">=</span> <span class="n">get_normfactor</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span>
                                       <span class="n">convolve_data1</span><span class="o">=</span><span class="n">convolve_data1</span><span class="p">,</span>
                                       <span class="n">convolve_data2</span><span class="o">=</span><span class="n">convolve_data2</span><span class="p">,</span>
                                       <span class="n">median_filter</span><span class="o">=</span><span class="n">median_filter</span><span class="p">,</span> <span class="n">border</span><span class="o">=</span><span class="n">border</span><span class="p">,</span>
                                       <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">,</span>
                                       <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>

        <span class="c1"># If normalising, use the polypar slope and background</span>
        <span class="k">if</span> <span class="n">normalise</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="n">upipe</span><span class="o">.</span><span class="n">print_info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Renormalising the data as: Normalised = &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">polypar</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">8.4e</span><span class="si">}</span><span class="s2"> * (</span><span class="si">{</span><span class="n">polypar</span><span class="o">.</span><span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">8.4e</span><span class="si">}</span><span class="s2"> + MUSE)&quot;</span><span class="p">)</span>

            <span class="n">data1</span> <span class="o">=</span> <span class="n">my_linear_model</span><span class="p">(</span><span class="n">polypar</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="n">data1</span><span class="p">)</span>

        <span class="c1"># Save the frames in case this is needed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temp_aligned</span> <span class="o">=</span> <span class="n">data1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_temp_reference</span> <span class="o">=</span> <span class="n">data2</span>

        <span class="c1"># WCS for plotting using astropy</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plotwcs</span> <span class="o">=</span> <span class="n">awcs</span><span class="o">.</span><span class="n">WCS</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plotwcs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Preparing the figure</span>
        <span class="n">current_fig</span> <span class="o">=</span> <span class="n">start_nfig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_figures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">foldfig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">figures_folder_name</span>

        <span class="k">if</span> <span class="n">suffix_fig</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">suffix_fig</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">suffix_fig</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Starting the plotting</span>
        <span class="k">if</span> <span class="n">shownormalise</span><span class="p">:</span>
            <span class="n">plot_polypar</span><span class="p">(</span><span class="n">polypar</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;MuseData&quot;</span><span class="p">,</span> <span class="s2">&quot;RefData&quot;</span><span class="p">],</span> <span class="n">figfolder</span><span class="o">=</span><span class="n">foldfig</span><span class="p">,</span>
                         <span class="n">fignum</span><span class="o">=</span><span class="n">current_fig</span><span class="p">,</span> <span class="n">namefig</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;align_norm_scatter</span><span class="si">{</span><span class="n">suffix_fig</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">,</span>
                         <span class="n">savefig</span><span class="o">=</span><span class="n">savefig</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_figures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_fig</span><span class="p">)</span>
            <span class="n">current_fig</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">showcontours</span><span class="p">:</span>
            <span class="n">plot_compare_contours</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">plotwcs</span><span class="o">=</span><span class="n">plotwcs</span><span class="p">,</span> <span class="n">fignum</span><span class="o">=</span><span class="n">current_fig</span><span class="p">,</span>
                                  <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;MUSE&#39;</span><span class="p">,</span> <span class="s1">&#39;REF&#39;</span><span class="p">],</span> <span class="n">nlevels</span><span class="o">=</span><span class="n">nlevels</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span>
                                  <span class="n">figfolder</span><span class="o">=</span><span class="n">foldfig</span><span class="p">,</span> <span class="n">namefig</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;align_contours</span><span class="si">{</span><span class="n">suffix_fig</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">,</span>
                                  <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Image </span><span class="si">{</span><span class="n">suffix_fig</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_figures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_fig</span><span class="p">)</span>
            <span class="n">current_fig</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">showcuts</span><span class="p">:</span>
            <span class="n">plot_compare_cuts</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">ncuts</span><span class="o">=</span><span class="n">ncuts</span><span class="p">,</span> <span class="n">fignum</span><span class="o">=</span><span class="n">current_fig</span><span class="p">,</span> <span class="n">figfolder</span><span class="o">=</span><span class="n">foldfig</span><span class="p">,</span>
                              <span class="n">namefig</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;align_cuts</span><span class="si">{</span><span class="n">suffix_fig</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="n">savefig</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_figures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_fig</span><span class="p">)</span>
            <span class="n">current_fig</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">showdiff</span><span class="p">:</span>
            <span class="n">plot_compare_diff</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">,</span> <span class="n">plotwcs</span><span class="o">=</span><span class="n">plotwcs</span><span class="p">,</span> <span class="n">fignum</span><span class="o">=</span><span class="n">current_fig</span><span class="p">,</span>
                              <span class="n">figfolder</span><span class="o">=</span><span class="n">foldfig</span><span class="p">,</span> <span class="n">percentage</span><span class="o">=</span><span class="n">percentage</span><span class="p">,</span>
                              <span class="n">namefig</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;align_diff</span><span class="si">{</span><span class="n">suffix_fig</span><span class="si">}</span><span class="s2">.png&quot;</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="n">savefig</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">list_figures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_fig</span><span class="p">)</span>
            <span class="n">current_fig</span> <span class="o">+=</span> <span class="mi">1</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019, Eric Emsellem.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>